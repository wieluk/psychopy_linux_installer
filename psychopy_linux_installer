#!/bin/bash
# ==============================================================================
#  Title:         psychopy_linux_installer
#  Description:   This script installs PsychoPy with specified versions of
#                 Python, wxPython, and optional packages.
#  Author:        Lukas Wiertz
#  Date:          2025-05-16
#  Version:       1.7.0
#  License:       GNU General Public License v3.0
# ==============================================================================

# Define default values
declare -A DEFAULT_OPTS=(
    [PSYCHOPY_VERSION]="latest"
    [PYTHON_VERSION]="3.10"
    [WXPYTHON_VERSION]="4.2.3"
    [BUILD_PYTHON]=false
    [BUILD_WX]=false
    [INSTALL_DIR]="/usr/local/psychopy"
    [VENV_NAME]=""
    [ADDITIONAL_PACKAGES]=""
    [SUDO_MODE]="ask"
    [DISABLE_SHORTCUT]=false
    [DISABLE_PATH]=false
    [NON_INTERACTIVE]=false
    [REMOVE_PSYCHOPY_SETTINGS]=false
    [FORCE_OVERWRITE]=false
    [VERBOSE]=false
)

# Displays usage information and available options.
show_help() {
    local help_text
    help_text=$(
        printf "%s\n" \
            "Usage: ./psychopy_linux_installer [options]" \
            "Options:" \
            "  --psychopy-version=VERSION                    Specify PsychoPy version (default: ${DEFAULT_OPTS[PSYCHOPY_VERSION]})." \
            "  --python-version=3.8|3.9|3.10                 Specify Python version (default: ${DEFAULT_OPTS[PYTHON_VERSION]})." \
            "  --wxpython-version=VERSION                    Specify wxPython version (default: ${DEFAULT_OPTS[WXPYTHON_VERSION]})." \
            "  --install-dir=DIR                             Specify installation directory (default: \"${DEFAULT_OPTS[INSTALL_DIR]}\")." \
            "  --venv-name=NAME                              Specify a custom name for the virtual environment folder. If omitted, a versioned subdirectory will be used by default. If installing into the default --install-dir, the name cannot be 'python' (case-insensitive)." \
            "  --additional-packages=PKG,PKG,...             Specify additional pip packages to install. Format: package1==version,package2." \
            "  --requirements-file=FILE                      Install all pip packages from FILE (e.g. a requirements.txt generated by the PsychoPy BIDS plugin) into the PsychoPy virtual environment." \
            "  --build=[python|wxpython|both]                Build Python and/or wxPython from source instead of downloading. Not recommended, only use if installation doesn't work as expected." \
            "  --sudo-mode=[ask|auto|error|continue|force]   Control sudo usage. ask: confirm, auto: auto-confirm, error: exit if sudo needed, continue: continue without sudo, force: use sudo directly (default: ${DEFAULT_OPTS[SUDO_MODE]})." \
            "  --non-interactive                             Run the installer without user interaction. Sets sudo-mode to auto if not set." \
            "  --disable-shortcut                            Disable desktop shortcut creation." \
            "  --disable-path                                Disable adding PsychoPy to system path." \
            "  --remove-psychopy-settings                    Remove existing PsychoPy user settings (${HOME}/.psychopy3). Retaining this folder can sometimes result in conflicts with plugins or non-default pip-installed packages." \
            "  --gui                                         Launches the installer in GUI mode, allowing you to set arguments interactively. Any arguments provided via the command line will be ignored while in GUI mode." \
            "  -f, --force-overwrite                         Force overwrite of existing installation directory." \
            "  -v, --verbose                                 Enable verbose output for the terminal (logfile output is always verbose)." \
            "  --version                                     Show the version of the installer." \
            "  -h, --help                                    Show this help message."
    )
    echo "${help_text}"
}

# cleanup infrastructure
declare -a TEMP_PATHS=()
register_cleanup() { TEMP_PATHS+=("$@"); }

cleanup() {
    for p in "${TEMP_PATHS[@]}"; do
        if [[ -e ${p} ]]; then
            log log_message "INFO: removing temporary path '${p}' â€¦"
            sudo_wrapper rm -rf "${p}"
        fi
    done
}

trap cleanup EXIT

# Log message function that writes colored output to terminal and plain text to the log file. It also handles exits on error.
log_message() {
    local reset="\033[0m" green="\033[32m" yellow="\033[33m" red="\033[31m" cyan="\033[36m"
    local timestamp formatted_message plain_message
    local nolog_option="${2}"
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Disable colors if output is not a terminal.
    if [[ ! -t 1 ]]; then
        reset=""
        green=""
        yellow=""
        red=""
        cyan=""
    fi

    case "${1}" in
    INFO:*)
        formatted_message=$(printf "%s - %b%s%b" "${timestamp}" "${green}" "${1}" "${reset}")
        ;;
    WARNING:*)
        formatted_message=$(printf "%s - %b%s%b" "${timestamp}" "${yellow}" "${1}" "${reset}")
        ;;
    ERROR:*)
        formatted_message=$(printf "%s - %b%s%b" "${timestamp}" "${red}" "${1}" "${reset}")
        ;;
    NOTE:*)
        formatted_message=$(printf "%s - %b%s%b" "${timestamp}" "${cyan}" "${1}" "${reset}")
        ;;
    *)
        formatted_message=$(printf "%s - %s" "${timestamp}" "${1}")
        ;;
    esac

    plain_message="${timestamp} - ${1}"

    if [[ "${FUNCNAME[1]}" != "log" ]]; then
        echo "${plain_message}" >>"${LOG_FILE}"
    fi

    printf "%s\n" "${formatted_message}"

    if [[ "${1}" == ERROR:* ]]; then
        if [[ "${nolog_option}" != "nolog" ]]; then
            printf "%bPlease check the log file at %s for more details.%b\n" "${red}" "${LOG_FILE}" "${reset}"
        fi
        printf "%bExiting.%b\n" "${red}" "${reset}"
        exit 1
    fi
}

# Wrapper to control command output based on verbosity.
log() {
    if [ "${VERBOSE}" = true ]; then
        "${@}" 2>&1 | tee -a "${LOG_FILE}"
        return "${PIPESTATUS[0]}"
    else
        "${@}" >>"${LOG_FILE}" 2>&1
        return ${?}
    fi
}

# Parses the command-line arguments and sets appropriate variables.
process_arguments() {
    local sudo_mode_set build_arg
    sudo_mode_set=false

    for arg in "${@}"; do
        case ${arg} in
        --psychopy-version=*)
            PSYCHOPY_VERSION="${arg#*=}"
            ;;
        --python-version=*)
            PYTHON_VERSION="${arg#*=}"
            if [[ ! ${PYTHON_VERSION} =~ ^3\.(8|9|10)$ ]]; then
                log_message "ERROR: Unsupported Python version '${PYTHON_VERSION}'. Supported versions: '3.8', '3.9', or '3.10'." nolog
            fi
            ;;
        --wxpython-version=*)
            WXPYTHON_VERSION="${arg#*=}"
            ;;
        --install-dir=*)
            INSTALL_DIR="${arg#*=}"
            ;;
        --venv-name=*)
            VENV_NAME="${arg#*=}"
            ;;
        --additional-packages=*)
            ADDITIONAL_PACKAGES="${arg#*=}"
            ;;
        --requirements-file=*)
            REQUIREMENTS_FILE="${arg#*=}"
            ;;
        --build=*)
            build_arg="${arg#*=}"
            case ${build_arg} in
            python)
                BUILD_PYTHON=true
                ;;
            wxpython)
                BUILD_WX=true
                ;;
            both)
                BUILD_PYTHON=true
                BUILD_WX=true
                ;;
            *)
                log_message "ERROR: Invalid --build option: '${build_arg}'." nolog
                show_help
                ;;
            esac
            ;;
        --sudo-mode=*)
            SUDO_MODE="${arg#*=}"
            if [[ "${SUDO_MODE}" != "ask" && "${SUDO_MODE}" != "continue" && "${SUDO_MODE}" != "auto" && "${SUDO_MODE}" != "error" && "${SUDO_MODE}" != "force" ]]; then
                log_message "ERROR: Invalid value for --sudo-mode. Valid options are 'ask', 'continue', 'auto', 'error' or 'force'." nolog
            fi
            sudo_mode_set=true
            ;;
        --non-interactive)
            NON_INTERACTIVE=true
            if [ "${sudo_mode_set}" = false ]; then
                SUDO_MODE=auto
            fi
            ;;
        --disable-shortcut)
            DISABLE_SHORTCUT=true
            ;;
        --disable-path)
            DISABLE_PATH=true
            ;;
        --remove-psychopy-settings)
            REMOVE_PSYCHOPY_SETTINGS=true
            ;;
        --gui)
            ;;
        -f | --force-overwrite)
            FORCE_OVERWRITE=true
            ;;
        -v | --verbose)
            VERBOSE=true
            ;;
        --version)
            grep -m 1 '^#  Version:' "$0" | awk -F: '{gsub(/ /,"",$2); print $2}'
            exit 0
            ;;
        -h | --help)
            show_help
            exit 0
            ;;
        *)
            show_help
            log_message "ERROR: Unknown option: '${arg}'." nolog
            ;;
        esac
    done

    if [[ "${PYTHON_VERSION}" == "3.8" ]]; then
        if [[ -z "${WXPYTHON_VERSION}" ]]; then
            WXPYTHON_VERSION="4.2.2"
            log_message "INFO: Python 3.8 selected. Only wxPython versions up to 4.2.2 are compatible."
        elif is_version_greater "${WXPYTHON_VERSION}" "4.2.2"; then
            log_message "ERROR: wxPython > 4.2.2 is not supported with Python 3.8." nolog
        fi
    fi
}

# Launches a Zenity-based GUI to collect user input interactively.
show_gui() {
    local wxpython_versions psychopy_versions options checklist_result

    # Checkbox page
    if  checklist_result=$(zenity --list --checklist --title="Customize Installation" --width=800 --height=500 \
        --text="Select which options you want to customize. Unchecked options will use defaults." \
        --column="Select" --column="Option" --column="Default" \
        FALSE "Install directory" "${DEFAULT_OPTS[INSTALL_DIR]}" \
        FALSE "Virtual environment name" "PsychoPy-{PSYCHOPY_VERSION}-Python{PYTHON_VERSION}" \
        FALSE "PsychoPy version" "${DEFAULT_OPTS[PSYCHOPY_VERSION]}" \
        FALSE "Python version" "${DEFAULT_OPTS[PYTHON_VERSION]}" \
        FALSE "wxPython version" "${DEFAULT_OPTS[WXPYTHON_VERSION]}" \
        FALSE "Additional pip packages" "None" \
        FALSE "Use requirements.txt" "False" \
    ); then
        :
    else
        exit 0
    fi

    # Install dir
    if [[ "${checklist_result}" == *"Install directory"* ]]; then
        if INSTALL_DIR=$(zenity --file-selection --directory --title="Select Installation Directory" --filename="${DEFAULT_OPTS[INSTALL_DIR]}/") && [ -n "${INSTALL_DIR}" ]; then
            INSTALL_DIR=$(echo "${INSTALL_DIR}" | xargs)
        else
            exit 0
        fi
    fi

    # Venv name
    if [[ "${checklist_result}" == *"Virtual environment name"* ]]; then
        if VENV_NAME=$(zenity --entry --title="Virtual Environment Name" --width=800 --height=500 \
            --text="Enter a name for the virtual environment folder.\n\n\nNotes:\nSpaces in the name will be replaced with underscores.\nThe name cannot be 'python' or any existing system command, as it will be used in your PATH.\n\n" \
            --entry-text=""); then
            VENV_NAME=$(echo "${VENV_NAME}" | xargs)
        else
            exit 0
        fi
    fi

    # PsychoPy version
    if [[ "${checklist_result}" == *"PsychoPy version"* ]]; then
        psychopy_versions="$(fetch_versions_from_pypi psychopy) + git"
        IFS=' ' read -r -a psychopy_false_opts <<<"$(echo "${psychopy_versions}" | xargs -I{} printf "FALSE %s " {})"
        if PSYCHOPY_VERSION=$(zenity --list --title="PsychoPy Version" --width=800 --height=500 \
            --text="Select the PsychoPy version:" \
            --radiolist --column="Select" --column="Version" \
            TRUE "${DEFAULT_OPTS[PSYCHOPY_VERSION]}" "${psychopy_false_opts[@]}" | tr -d '"') && [ -n "${PSYCHOPY_VERSION}" ]; then
            PSYCHOPY_VERSION=$(echo "${PSYCHOPY_VERSION}" | xargs)
        else
            exit 0
        fi
    fi

    # Python version
    if [[ "${checklist_result}" == *"Python version"* ]]; then
        if PYTHON_VERSION=$(zenity --list --title="Select Python Version" --width=800 --height=500 \
            --text="Choose the Python version for this installation.\n\n" \
            --radiolist --column="Select" --column="Version" \
            TRUE "3.10" FALSE "3.9" FALSE "3.8") && [ -n "${PYTHON_VERSION}" ]; then
            PYTHON_VERSION=$(echo "${PYTHON_VERSION}" | xargs)
        else
            exit 0
        fi
    fi

    # wxPython version
    if [[ "${checklist_result}" == *"wxPython version"* ]]; then
        wxpython_versions=$(fetch_versions_from_pypi wxPython)
        if [[ "${PYTHON_VERSION}" == "3.8" ]]; then
            log_message "INFO: Python 3.8 selected. Only wxPython versions up to 4.2.2 are compatible."
            wxpython_versions=$(echo "${wxpython_versions}" | awk '$1 <= "4.2.2"')
            wxpython_default="4.2.2"
        else
            wxpython_default="${DEFAULT_OPTS[WXPYTHON_VERSION]}"
        fi
        IFS=' ' read -r -a wxpython_false_opts <<<"$(echo "${wxpython_versions}" | grep -v "${wxpython_default}" | xargs -I{} printf "FALSE %s " {})"
        if WXPYTHON_VERSION=$(zenity --list --title="Select wxPython Version" --width=800 --height=500 \
            --text="Choose the wxPython version for this installation." \
            --radiolist --column="Select" --column="Version" \
            TRUE "${wxpython_default}" "${wxpython_false_opts[@]}" | tr -d '"') && [ -n "${WXPYTHON_VERSION}" ]; then
            WXPYTHON_VERSION=$(echo "${WXPYTHON_VERSION}" | xargs)
        else
            exit 0
        fi
    fi

    # Additional pip packages
    if [[ "${checklist_result}" == *"Additional pip packages"* ]]; then
        if ADDITIONAL_PACKAGES=$(zenity --entry --title="Additional Packages" --width=800 --height=500 \
            --text="Specify additional pip packages to install (comma-separated).\n\nExample:\npsychopy-bids,another-package==1.2.3,package3\n\n" \
            --entry-text=""); then
            ADDITIONAL_PACKAGES=$(echo "${ADDITIONAL_PACKAGES}" | xargs)
        else
            exit 0
        fi
    fi

    # requirements.txt
    if [[ "${checklist_result}" == *"Use requirements.txt"* ]]; then
        if REQUIREMENTS_FILE=$(zenity --file-selection --title="Select requirements.txt" --file-filter="requirements.txt | *.txt") && [ -n "${REQUIREMENTS_FILE}" ]; then
            :
        else
            exit 0
        fi
    fi

    # Additional options
    if options=$(zenity --list --checklist --title="Additional Options" --width=800 --height=500 \
        --text="Select additional options:" \
        --column="Select" --column="Option" \
        TRUE "Add PsychoPy to system PATH" \
        TRUE "Create desktop shortcuts" \
        FALSE "Run in non-interactive mode" \
        FALSE "Force overwrite of existing directory" \
        FALSE "Remove PsychoPy user settings (${HOME}/.psychopy3)" \
        FALSE "Build Python from source" \
        FALSE "Build wxPython from source" \
        FALSE "Enable verbose output"); then
        :
    else
        exit 0
    fi

    if [[ ${options} == *"Add PsychoPy to system PATH"* ]]; then
        DISABLE_PATH=false
    else
        DISABLE_PATH=true
    fi

    if [[ ${options} == *"Create desktop shortcuts"* ]]; then
        DISABLE_SHORTCUT=false
    else
        DISABLE_SHORTCUT=true
    fi

    if [[ ${options} == *"Run in non-interactive mode"* ]]; then
        NON_INTERACTIVE=true
        SUDO_MODE=auto
    else
        NON_INTERACTIVE=false
    fi

    if [[ ${options} == *"Force overwrite of existing directory"* ]]; then
        FORCE_OVERWRITE=true
    fi

    if [[ ${options} == *"Remove PsychoPy user settings (${HOME}/.psychopy3)"* ]]; then
        REMOVE_PSYCHOPY_SETTINGS=true
    fi

    if [[ ${options} == *"Build Python from source"* ]]; then
        BUILD_PYTHON=true
    fi

    if [[ ${options} == *"Build wxPython from source"* ]]; then
        BUILD_WX=true
    fi

    if [[ ${options} == *"Enable verbose output"* ]]; then
        VERBOSE=true
    fi

    # Sudo mode selection
    if [[ ${NON_INTERACTIVE} == false ]]; then
        if SUDO_MODE=$(zenity --list --title="Sudo Mode" --width=800 --height=500 \
            --text="Select the desired sudo mode:\n\n \
                    ask: Prompt each time sudo is needed.\n \
                    auto: Automatically use sudo when required.\n \
                    error: Exit immediately if a command requires sudo.\n \
                    continue: Attempt to run commands without sudo. If they fail due to missing permissions, proceed without stopping.\n \
                    force: Always use sudo for commands that typically require it, without checking necessity.\n\n" \
            --radiolist --column="Select" --column="Mode" \
            TRUE "ask" FALSE "auto" FALSE "error" FALSE "continue" FALSE "force") && [ -n "${SUDO_MODE}" ]; then
            :
        else
            exit 0
        fi
    fi
}

# Reconstructs a command string to re-run the installer with the current settings.
create_rerun_command() {
    local cmd lowercase_key curr def
    cmd=$(readlink -f "${0}")
    for key in "${!DEFAULT_OPTS[@]}"; do
        [[ "${key}" == "BUILD_PYTHON" || "${key}" == "BUILD_WX" ]] && continue
        curr="${!key}"
        def="${DEFAULT_OPTS[${key}]}"
        lowercase_key=$(echo "${key}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
        if [[ "${curr}" != "${def}" ]]; then
            if [[ "${curr}" == "true" && "${def}" == "false" ]]; then
                cmd+=" --${lowercase_key}"
            elif [[ -n "${curr}" ]]; then
                cmd+=" --${lowercase_key}=${curr}"
            fi
        fi
    done
    if [[ "${BUILD_PYTHON}" == true && "${BUILD_WX}" == true ]]; then
        cmd+=" --build=both"
    elif [[ "${BUILD_PYTHON}" == true ]]; then
        cmd+=" --build=python"
    elif [[ "${BUILD_WX}" == true ]]; then
        cmd+=" --build=wxpython"
    fi
    [ -n "${REQUIREMENTS_FILE}" ] && cmd+=" --requirements-file=${REQUIREMENTS_FILE}"
    echo "${cmd}"
}

# Reads and parses a requirements file, adjusting dependency versions as needed.
parse_requirements_file() {
    local file current_version operator package_name package_version pkg_lower version original_spec new_spec req_python_version req_wxpython_version req_psychopy_version skipped_packages adjusted_packages req_packages_list raw_packages_list
    local -A package_versions
    local -A package_operators
    file="${1}"

    if [ ! -f "${file}" ] || [ ! -s "${file}" ] || [ ! -r "${file}" ]; then
        log_message "ERROR: Requirements file '${file}' is missing, empty, or inaccessible." nolog
    fi

    while IFS= read -r line; do
        if [[ "${line}" =~ ^# ]] || [[ -z "${line}" ]]; then
            continue
        fi

        if [[ "${line}" =~ ^([A-Za-z0-9._-]+)[[:space:]]*(>=|<=|==|~=|!=|>|<)[[:space:]]*([0-9][A-Za-z0-9._-]*) ]]; then
            package_name="${BASH_REMATCH[1],,}"
            operator="${BASH_REMATCH[2]}"
            package_version="${BASH_REMATCH[3]}"
            raw_packages_list+=("${package_name}${operator}${package_version}")

            if [[ -n "${package_versions[${package_name}]}" ]]; then
                current_version="${package_versions[${package_name}]}"
                if [[ "${operator}" == "==" || "${package_operators[${package_name}]}" != "==" ]]; then
                    package_versions["${package_name}"]="${package_version}"
                    package_operators["${package_name}"]="${operator}"
                fi
            else
                package_versions["${package_name}"]="${package_version}"
                package_operators["${package_name}"]="${operator}"
            fi
        fi
    done <"${file}"

    for pkg in "${!package_versions[@]}"; do
        if [[ "${pkg}" != "wxpython" && "${pkg}" != "psychopy" && "${pkg}" != "winrt" && "${pkg}" != "pywin32" && "${pkg}" != "pypiwin32" && "${pkg}" != "pywinhook" ]]; then
            req_packages_list+=("${pkg}${package_operators[${pkg}]}${package_versions[${pkg}]}")
        else
            if [[ "${pkg}" != "wxpython" && "${pkg}" != "psychopy" ]]; then
                skipped_packages+=("${pkg}")
            fi
        fi
    done
    REQUIREMENTSFILE_PACKAGES=$(IFS=','; echo "${req_packages_list[*]}")
    if [ ${#skipped_packages[@]} -gt 0 ]; then
        log_message "WARNING: The following pip packages from requirements.txt are not available on Linux and were skipped: ${skipped_packages[*]}" >&2
    fi

    # Extract versions from requirements file
    req_python_version=$(grep -i -E '^# Python version:' "${file}" | cut -d':' -f2 | xargs | cut -d'.' -f1,2 | tr -d '[:space:]' || true)
    req_wxpython_version="${package_versions["wxpython"]:-}"
    req_psychopy_version="${package_versions["psychopy"]:-}"

    # Set or warn for Python version, wxPython version, and PsychoPy version
    if [ -n "${PYTHON_VERSION}" ] && [ -n "${req_python_version}" ] && [ "${PYTHON_VERSION}" != "${req_python_version}" ]; then
        log_message "WARNING: Python version already set to '${PYTHON_VERSION}', but requirements file specifies '${req_python_version}'. Using '${PYTHON_VERSION}'."
    elif [ -z "${PYTHON_VERSION}" ] && [ -n "${req_python_version}" ]; then
        PYTHON_VERSION="${req_python_version}"
    fi

    if [ -n "${WXPYTHON_VERSION}" ] && [ -n "${req_wxpython_version}" ] && [ "${WXPYTHON_VERSION}" != "${req_wxpython_version}" ]; then
        log_message "WARNING: wxPython version already set to '${WXPYTHON_VERSION}', but requirements file specifies '${req_wxpython_version}'. Using '${WXPYTHON_VERSION}'."
    elif [ -z "${WXPYTHON_VERSION}" ] && [ -n "${req_wxpython_version}" ]; then
        WXPYTHON_VERSION="${req_wxpython_version}"
    fi

    if [ -n "${PSYCHOPY_VERSION}" ] && [ -n "${req_psychopy_version}" ] && [ "${PSYCHOPY_VERSION}" != "${req_psychopy_version}" ]; then
        log_message "WARNING: PsychoPy version already set to '${PSYCHOPY_VERSION}', but requirements file specifies '${req_psychopy_version}'. Using '${PSYCHOPY_VERSION}'."
    elif [ -z "${PSYCHOPY_VERSION}" ] && [ -n "${req_psychopy_version}" ]; then
        PSYCHOPY_VERSION="${req_psychopy_version}"
    fi

    [[ -z "${PYTHON_VERSION}" ]] && log_message "WARNING: Python version not specified in the requirements file; using default: '${DEFAULT_OPTS[PYTHON_VERSION]}'."
    [[ -z "${WXPYTHON_VERSION}" ]] && log_message "WARNING: wxPython version not specified in the requirements file; using default: '${DEFAULT_OPTS[WXPYTHON_VERSION]}'."
    [[ -z "${PSYCHOPY_VERSION}" ]] && log_message "WARNING: psychopy version not specified in the requirements file; using default: '${DEFAULT_OPTS[PSYCHOPY_VERSION]}'."

    # Adjust Linux dependencies
    for pkg in pyglet python-vlc; do
        pkg_lower="${pkg,,}"
        if [[ -n "${package_versions[${pkg_lower}]}" ]]; then
            version="${package_versions[${pkg_lower}]}"
            original_spec="${pkg_lower}${package_operators[${pkg_lower}]}${version}"
            new_spec="${pkg_lower}>=${version}"
            if [[ "${REQUIREMENTSFILE_PACKAGES}" == *"${original_spec}"* ]]; then
                REQUIREMENTSFILE_PACKAGES=${REQUIREMENTSFILE_PACKAGES//"${original_spec}"/"${new_spec}"}
                adjusted_packages+=(" '${original_spec}' â†’ '${new_spec}' ")
            fi
        fi
    done
    if [ ${#adjusted_packages[@]} -gt 0 ]; then
        log_message "WARNING: The following pip requirements were adjusted for Linux compatibility: ${adjusted_packages[*]}. You may try to manually install the exact versions in the PsychoPy venv if needed."
    fi
}

# Manages sudo usage and command retries when permissions are insufficient.
sudo_wrapper() {
    local error_output exit_code
    local command=("${@}")
    local is_pkg_manager_command=false

    needs_sudo() {
        local exit_code="${1}"
        local error_output="${2}"

        case ${exit_code} in
        0) return 1 ;;
        1 | 2 | 5 | 10 | 13 | 77 | 100 | 126 | 127) return 0 ;;
        *)
            log_message "WARNING: Unhandled exit code '${exit_code}'. Error output: '${error_output}'. Attempting to continue ..."
            return 1
            ;;
        esac
    }

    setup_temporary_sudo_timeout() {
        if [ "${TEMPORARY_SUDO_SETUP_DONE}" = true ]; then
            return
        fi
        TEMP_SUDOERS="/etc/sudoers.d/temporary_timeout"
        register_cleanup "${TEMP_SUDOERS}"
        TEMPORARY_SUDO_SETUP_DONE=true
        log_message "INFO: Temporary sudo timeout set to 300 minutes (configured in '${TEMP_SUDOERS}')."
        sudo_wrapper sh -c "echo 'Defaults        timestamp_timeout=300' > ${TEMP_SUDOERS}"
        sudo_wrapper chmod 440 ${TEMP_SUDOERS}
    }

    handle_sudo_request() {
        local response
        local command=("${@}")

        case "${SUDO_MODE}" in
        ask)
            if ${is_pkg_manager_command}; then
                retry_text="[r] Retry with sudo (this and future '${PKG_MANAGER}' commands)"
            else
                retry_text="[r] Retry with sudo"
            fi

            log_message "WARNING: Command '${command[*]}' failed with error: '${error_output}'."
            echo
            read -r -p "How would you like to proceed?

            ${retry_text}
            [a] Automatically use sudo when needed  (this and future commands)
            [c] Continue without sudo (this command will be skipped)
            [q] Quit

            Enter your choice [r/a/c/q]: " response
            echo

            case "${response}" in
            [Rr])
                if ${is_pkg_manager_command}; then
                    PKG_MANAGER_PERMISSION=true
                fi
                log_message "INFO: Retrying command '${command[*]}' with sudo ..."
                log sudo "${command[@]}"
                ;;
            [Cc]) ;;
            [aA])
                SUDO_MODE=auto
                setup_temporary_sudo_timeout
                log_message "INFO: Retrying command '${command[*]}' with sudo (sudo-mode set to auto) ..."
                log sudo "${command[@]}"
                ;;
            *)
                log_message "INFO: Exiting."
                exit 0
                ;;
            esac
            ;;
        auto)
            setup_temporary_sudo_timeout
            if ${is_pkg_manager_command}; then
                PKG_MANAGER_PERMISSION=true
            fi
            log log_message "WARNING: Command '${command[*]}' failed with: '${error_output}'. Using sudo ..."
            log sudo "${command[@]}"
            ;;
        continue)
            log_message "WARNING: Command '${command[*]}' failed with: '${error_output}'. Continuing without sudo ..."
            ;;
        error)
            log_message "WARNING: Command '${command[*]}' failed with '${error_output}'. Sudo is required, but mode is set to 'error'."
            exit 1
            ;;
        esac
    }

    is_pkg_manager_command=$([ "${1}" == "${PKG_MANAGER}" ] && echo true || echo false)

    if [[ "${SUDO_MODE}" == "force" || ("${is_pkg_manager_command}" == true && "${PKG_MANAGER_PERMISSION}" == true) ]]; then
        log sudo "${command[@]}"
        return
    fi

    error_output=$("${command[@]}" 2>&1)
    exit_code=${?}

    if needs_sudo "${exit_code}" "${error_output}"; then
        handle_sudo_request "${command[@]}"
    fi
}

# Try to connect to github.com
check_connection() {
    if (bash -c "echo >/dev/tcp/github.com/443" &>/dev/null); then
        return 0
    else
        log_message "ERROR: No internet connection. This script requires internet access to download packages." nolog
    fi
}

# Checks for a new version of the installer script and prompts the user to update.
check_script_update() {
    local latest_url="https://github.com/wieluk/psychopy_linux_installer/releases/latest/download/psychopy_linux_installer"
    local current_version latest_version rerun_cmd

    # Extract version information from the current and latest scripts.
    current_version=$(grep -m 1 'Version:' "${0}" | sed 's/[^0-9.]//g')
    latest_version=$(curl -sL "${latest_url}" | grep -m 1 'Version:' | sed 's/[^0-9.]//g')

    if is_version_greater "${latest_version}" "${current_version}"; then
        echo -e "\nA new version (${latest_version}) of the installer script is available."
        echo "    ðŸ”¹ Repository: https://github.com/wieluk/psychopy_linux_installer"
        echo "    ðŸ”¹ Releases:   https://github.com/wieluk/psychopy_linux_installer/releases"
        echo "    ðŸ”¹ Issues:     https://github.com/wieluk/psychopy_linux_installer/issues"
        echo

        local script_path
        script_path=$(readlink -f "${0}")
        echo
        read -r -p "Would you like to update?

        [y] Yes
        [n] No

        Enter your choice [y/n]: " response
        echo

        if [[ "${response}" =~ ^[Yy]$ ]]; then
            log_message "INFO: Updating to version '${latest_version}' ..."

            # Download and replace the current script with the latest release.
            if curl -sLo "${script_path}" "${latest_url}"; then
                log_message "INFO: Update completed successfully."
                rerun_cmd=$(create_rerun_command)
                log_message "NOTE: To re-run the installer with the current settings, use: '${rerun_cmd}'"
                exit 0
            else
                log_message "WARNING: Failed to download the update. Continuing with the current version."
            fi
        fi
    fi
}

# Determines the operating system and its version.
detect_os_version() {
    OS_VERSION=""
    OS_VERSION_LINK=""
    OS_VERSION_FULL=""

    local major_version version ID VERSION_ID
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        if [ -n "${ID}" ] && [ -n "${VERSION_ID}" ]; then
            ID=$(echo "${ID}" | tr '[:upper:]' '[:lower:]')
            VERSION_ID=$(echo "${VERSION_ID}" | tr '[:upper:]' '[:lower:]')
            major_version=$(echo "${VERSION_ID}" | cut -d. -f1)

            OS_VERSION="${ID}-${major_version}"
            OS_VERSION_FULL="${ID}-${VERSION_ID}"
            if [ "${ID}" = "ubuntu" ]; then
                OS_VERSION_LINK="${ID}-${VERSION_ID}"
            else
                OS_VERSION_LINK="${OS_VERSION}"
            fi
            return
        fi
    fi

    if command -v lsb_release >/dev/null 2>&1; then
        ID=$(lsb_release -si | tr '[:upper:]' '[:lower:]')
        version=$(lsb_release -sr | tr '[:upper:]' '[:lower:]')
        major_version=$(echo "${version}" | cut -d. -f1)

        OS_VERSION="${ID}-${major_version}"
        OS_VERSION_FULL="${ID}-${major_version}"
        if [ "${ID}" = "ubuntu" ]; then
            OS_VERSION_LINK="${ID}-${version}"
        else
            OS_VERSION_LINK="${OS_VERSION}"
        fi
        return
    fi

    log_message "WARNING: Unable to detect OS version."
    OS_VERSION="unknown"
    OS_VERSION_LINK="unknown"
    OS_VERSION_FULL="unknown"
    return
}

# Identifies the available package manager (apt-get, yum, etc.).
detect_package_manager() {
    if command -v apt-get >/dev/null 2>&1; then
        echo "apt-get"
    elif command -v yum >/dev/null 2>&1; then
        echo "yum"
    elif command -v dnf >/dev/null 2>&1; then
        echo "dnf"
    elif command -v pacman >/dev/null 2>&1; then
        echo "pacman"
    elif command -v zypper >/dev/null 2>&1; then
        echo "zypper"
    else
        log_message "ERROR: No compatible package manager found."
    fi
}

# Updates the package manager's database.
update_package_manager() {
    case ${PKG_MANAGER} in
    apt-get) sudo_wrapper apt-get update -qq ;;
    yum)     sudo_wrapper yum makecache -q ;;
    dnf)     sudo_wrapper dnf makecache -q ;;
    pacman)  log_message "WARNING: Skipping 'pacman -Syu' to avoid unintended system upgrades. If you encounter a lot of 'package not found' errors, manually run 'sudo pacman -Syu' to update your package database, then rerun this script." ;;
    zypper)  sudo_wrapper zypper refresh ;;
    *)
        log_message "ERROR: No compatible package manager found."
        ;;
    esac
}

is_package_installed() {
    case "${PKG_MANAGER}" in
        apt-get) dpkg -s "$1" &>/dev/null ;;
        yum|dnf) rpm -q "$1" &>/dev/null ;;
        pacman)  pacman -Q "$1" &>/dev/null ;;
        zypper)  rpm -q "$1" &>/dev/null ;;
        *)       return 1 ;;
    esac
}

# Installs the provided packages via the identified package manager.
install_packages() {
    local packages=("${@}")
    local available_packages
    local to_install=()
    local already_installed=()

    read -r -a available_packages <<<"$(filter_installable_packages "${packages[@]}")"

    # Using grep to compute the difference between packages and available_packages
    diff=$(printf "%s\n" "${packages[@]}" | grep -vxFf <(printf "%s\n" "${available_packages[@]}") | paste -sd, -)
    [ -n "${diff}" ] && log_message "WARNING: The following ${PKG_MANAGER} packages are not available and will be skipped: '${diff}'"

    for package in "${available_packages[@]}"; do
        if is_package_installed "${package}"; then
            already_installed+=("${package}")
        else
            to_install+=("${package}")
        fi
    done

    if [ ${#already_installed[@]} -gt 0 ]; then
        log log_message "INFO: The following ${PKG_MANAGER} packages are already installed: '${already_installed[*]}'"
    fi

    if [ ${#to_install[@]} -eq 0 ]; then
        if [ ${#already_installed[@]} -gt 0 ] && [ -n "${diff}" ]; then
            log log_message "INFO: Nothing to install - some ${PKG_MANAGER} packages already installed, others unavailable or skipped."
            return 0
        elif [ ${#already_installed[@]} -gt 0 ] && [ -z "${diff}" ]; then
            log log_message "INFO: Nothing to install - all requested ${PKG_MANAGER} packages are already installed."
            return 0
        else
            log_message "WARNING: Nothing to install - all requested ${PKG_MANAGER} packages unavailable or skipped."
            return 0
        fi
    fi

    if {
        case "${PKG_MANAGER}" in
        apt-get) sudo_wrapper apt-get install -y -qq "${to_install[@]}" ;;
        yum)     sudo_wrapper yum install -y -q "${to_install[@]}" ;;
        dnf)     sudo_wrapper dnf install -y -q "${to_install[@]}" ;;
        pacman)  sudo_wrapper pacman -S --needed --noconfirm "${to_install[@]}" ;;
        zypper)  sudo_wrapper zypper install -y "${to_install[@]}" ;;
        *)
            log_message "ERROR: No compatible package manager found."
            ;;
        esac
    } then
        return 0
    else
        log_message "WARNING: ${PKG_MANAGER} batch installation failed. Falling back to per-package installation. This might take sometime ..."
    fi

    # If batch install fails, fallback to installing packages one by one
    for package in "${packages[@]}"; do
        case ${PKG_MANAGER} in
        apt-get) sudo_wrapper apt-get install -y -qq "${package}" || log_message "WARNING: Package '${package}' not found, skipping." ;;
        yum)     sudo_wrapper yum install -y -q "${package}" || log_message "WARNING: Package '${package}' not found, skipping." ;;
        dnf)     sudo_wrapper dnf install -y -q "${package}" || log_message "WARNING: Package '${package}' not found, skipping." ;;
        pacman)  sudo_wrapper pacman -S --needed --noconfirm "${package}" || log_message "WARNING: Package '${package}' not found, skipping." ;;
        zypper)  sudo_wrapper zypper install -y "${package}" || log_message "WARNING: Package '${package}' not found, skipping." ;;
        *)
            log_message "ERROR: No compatible package manager found."
            ;;
        esac
    done
}

# Installs dependency groups
install_dependencies() {
    local dep_type dependencies script_deps psychopy_deps fonts python_build_deps wxpython_deps python_with_venv

    dep_type="${1}"
    dependencies=()

    case ${PKG_MANAGER} in
    apt-get)
        script_deps=(curl git jq)
        psychopy_deps=(libasound2-dev libegl1-mesa-dev libglib2.0-dev libgtk-3-dev libnotify4 libusb-1.0-0-dev libwebkit2gtk-4.0-dev libwebkit2gtk-4.1-dev libxcb-cursor0 libxcb-xinerama0 libxkbcommon-x11-0 libsdl2-dev libglu1-mesa-dev portaudio19-dev pulseaudio pulseaudio-utils)
        fonts=(fonts-dejavu fonts-liberation fontconfig)
        python_build_deps=(build-essential libbz2-dev libffi-dev libreadline-dev libsqlite3-dev libssl-dev make xz-utils zlib1g-dev)
        wxpython_deps=(pkgâ€‘config freeglut3-dev g++ gstreamer1.0-plugins-base gstreamer1.0-tools gstreamer1.0-x libgtk2.0-dev libjpeg-dev libnotify-dev libpng-dev libsm-dev libtiff-dev make)
        python_with_venv=(python3 python3-dev python3-pip python3-venv)
        ;;
    yum | dnf)
        script_deps=(curl git jq)
        psychopy_deps=(alsa-lib-devel gtk3-devel libnotify mesa-libEGL-devel mesa-libGLU-devel portaudio-devel pulseaudio pulseaudio-utils SDL2-devel webkit2gtk3-devel webkit2gtk4.0-devel libusb1-devel)
        fonts=(fontconfig dejavu-sans-fonts dejavu-serif-fonts liberation-sans-fonts liberation-serif-fonts liberation-mono-fonts)
        python_build_deps=(bzip2-devel gcc libffi-devel make openssl-devel readline-devel sqlite-devel xz-devel zlib-devel)
        wxpython_deps=(pkgconfig freeglut-devel gcc-c++ gstreamer1-devel gtk2-devel libSM-devel libjpeg-devel libjpeg-turbo-devel libnotify-devel libpng-devel libtiff-devel make glib2-devel)
        python_with_venv=(python3 python3-devel python3-pip python3-venv)
        ;;
    pacman)
        script_deps=(curl git jq)
        psychopy_deps=(alsa-lib gtk3 libnotify libusb mesa portaudio pulseaudio pulseaudio-utils SDL2 webkit2gtk xcb-util-cursor libxcb glu)
        fonts=(ttf-dejavu ttf-liberation noto-fonts gnu-free-fonts)
        python_build_deps=(base-devel bzip2 libffi make openssl readline sqlite xz zlib)
        wxpython_deps=(pkgconf freeglut gcc glib2 gstreamer gtk2 libjpeg libpng libsm libtiff make mesa)
        python_with_venv=(python python-pip python-virtualenv)
        ;;
    zypper)
        script_deps=(curl git jq)
        psychopy_deps=(alsa-devel gtk3-devel libnotify4 libusb-1_0-devel libxcb-xinerama0 portaudio-devel pulseaudio pulseaudio-utils SDL2-devel)
        fonts=(dejavu-fonts liberation-fonts fontconfig)
        python_build_deps=(gcc libffi-devel libopenssl-devel make readline-devel sqlite3-devel xz-devel zlib-devel)
        wxpython_deps=(pkgconfâ€‘pkgâ€‘config freeglut-devel gcc-c++ glib2-devel gstreamer-plugins-base libSM-devel libjpeg-turbo libnotify-devel libpng16-devel make libtiff-devel)
        python_with_venv=(python3 python3-devel python3-pip python3-virtualenv)
        ;;
    *)
        log_message "ERROR: No compatible package manager found."
        ;;
    esac

    case ${dep_type} in
    script_deps) dependencies=("${script_deps[@]}") ;;
    python_build_deps) dependencies=("${python_build_deps[@]}") ;;
    psychopy_deps) dependencies=("${psychopy_deps[@]}") ;;
    fonts) dependencies=("${fonts[@]}") ;;
    wxpython_deps) dependencies=("${wxpython_deps[@]}") ;;
    python_with_venv) dependencies=("${python_with_venv[@]}") ;;
    *)
        log_message "ERROR: Invalid dependency type specified."
        ;;
    esac

    install_packages "${dependencies[@]}"
}

# Filters and returns a list of packages available for installation.
filter_installable_packages() {
    local filtered_packages=()

    for package in "${@}"; do
        # Skip conflicting packages for specific OS versions
        case "${OS_VERSION}" in
        ubuntu-24) [[ "${package}" == "libwebkit2gtk-4.0-dev" ]] && continue ;;
        ubuntu-20) [[ "${package}" == "libwebkit2gtk-4.1-dev" ]] && continue ;;
        debian-11) [[ "${package}" == "libwebkit2gtk-4.1-dev" ]] && continue ;;
        pop-22) [[ "${package}" == "pulseaudio" ]] && continue ;;
        fedora-39 | fedora-40 | fedora-41) [[ "${package}" == "pulseaudio" ]] && continue ;;
        rocky-9 | centos-9) [[ "${package}" == "pulseaudio" || "${package}" == "portaudio-devel" ]] && continue ;;
        linuxmint-22) [[ "${package}" == "libwebkit2gtk-4.0-dev" ]] && continue ;;
        manjarolinux-25) [[ "${package}" == "pulseaudio-utils" || "${package}" == "pulseaudio" ]] && continue ;;
        esac

        case "${PKG_MANAGER}" in
        apt-get)
            if apt-cache show "${package}" &>/dev/null; then
                filtered_packages+=("${package}")
            fi
            ;;
        yum | dnf)
            if ${PKG_MANAGER} info "${package}" &>/dev/null; then
                filtered_packages+=("${package}")
            fi
            ;;
        pacman)
            if pacman -Si "${package}" &>/dev/null; then
                filtered_packages+=("${package}")
            fi
            ;;
        zypper)
            if zypper search --match-exact "${package}" &>/dev/null; then
                filtered_packages+=("${package}")
            fi
            ;;
        esac
    done
    echo "${filtered_packages[@]}"
}

install_pip_packages_with_fallback() {
    local packages_csv="$1"
    local pkg_name installed_version

    log_message "INFO: Installing extra pip packages from --additional-packages and/or --requirements-file."

    IFS=',' read -ra PACKAGES <<<"${packages_csv}"
    if log "${PYTHON_VENV_COMMAND}" -m pip install "${PACKAGES[@]}"; then
        log_message "INFO: All extra pip packages installed successfully."
    else
        log_message "WARNING: Failed to install extra pip packages as batch. Installing one by one ..."
        for package in "${PACKAGES[@]}"; do
            log log_message "INFO: Installing '${package}' ..."
            if log "${PYTHON_VENV_COMMAND}" -m pip install "${package}"; then
                log log_message "INFO: '${pkg_name}' version '${installed_version}' installed successfully."
            else
                log log_message "WARNING: Failed to install '${package}'. Skipping."
            fi
        done
    fi
}

# Verifies if the specific Python version is available through the package manager.
check_python_in_package_manager() {
    local available_version

    case ${PKG_MANAGER} in
    apt-get)
        available_version=$(apt-cache policy python3 | grep -m 1 "Candidate:" | awk '{print $2}' | cut -d'.' -f1,2)
        ;;
    yum)
        available_version=$(yum info python3 2>/dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
        ;;
    dnf)
        available_version=$(dnf info python3 2>/dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
        ;;
    pacman)
        available_version=$(pacman -Si python 2>/dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
        ;;
    zypper)
        available_version=$(zypper info python3 2>/dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
        ;;
    *)
        log_message "ERROR: No compatible package manager found."
        ;;
    esac

    if [ "${available_version}" == "${PYTHON_VERSION}" ]; then
        return 0
    else
        log_message "INFO: 'Python${PYTHON_VERSION}' not available in '${PKG_MANAGER}'."
        return 1
    fi
}

# Compares two version strings and returns true if the first is greater.
is_version_greater() {
    if [[ "${1}" =~ ^[0-9]+(\.[0-9]+)*$ ]] && [[ "${2}" =~ ^[0-9]+(\.[0-9]+)*$ ]]; then
        [ "$(printf '%s\n' "${@}" | sort -V | head -n 1)" != "${1}" ]
    else
        return 1
    fi
}

# Retrieves and sorts available versions for a package from PyPI.
fetch_versions_from_pypi() {
    local package="${1}"
    curl -s "https://pypi.org/pypi/${package}/json" | jq -r '.releases // {} | keys[]' | sort -Vr
}

# Retrieves the latest version for a package from PyPI.
get_latest_pypi_version() {
    local pkg="${1}"
    local var_name="${2}"

    local version
    version=$(curl -s "https://pypi.org/pypi/${pkg}/json" | jq -r '.info.version')
    if [ -z "${version}" ] || [ "${version}" = "null" ]; then
        log_message "ERROR: Unable to fetch the latest version for pip package '${package_name}'."
    fi
    declare -n result=${var_name}
    # shellcheck disable=SC2034
    result="${version}"
}

# Verifies that the requested package version exists on PyPI (or Git).
check_pypi_for_version() {
    local package="${1}"
    local version="${2}"
    local github_api="https://api.github.com/repos/psychopy/psychopy/git/refs/tags"
    local pypi_api="https://pypi.org/pypi"

    if curl -s "${pypi_api}/${package}/${version}/json" | jq -e .info.version >/dev/null; then
        return 0
    fi

    if [ "${package}" = "psychopy" ]; then
        if curl -s -H "Accept: application/vnd.github.v3+json" \
            "${github_api}/${version}" | jq -e .ref >/dev/null; then
            log_message "WARNING: '${package}' version '${version}' not found on PyPi but as GitHub tag"
            PSYCHOPY_GIT_TAG=true
            return 0
        fi
    fi

    log_message "ERROR: '${package}' version '${version}' not found on PyPI." nolog
}

# Confirms that Python, pip, and venv are available.
check_python_env() {
    local python_cmd="${1}"
    if ! command -v "${python_cmd}" >/dev/null 2>&1; then
        log_message "ERROR: '${python_cmd}' not found. Something went wrong while installing/building. Try '--build=python' as argument."
    fi

    if ! "${python_cmd}" -m venv --help >/dev/null 2>&1; then
        log_message "ERROR: '${python_cmd}' found, but venv module is not available. Something went wrong while installing/building. Try '--build=python' as argument."
    fi

    if ! "${python_cmd}" -m pip --version >/dev/null 2>&1; then
        log_message "ERROR: '${python_cmd}' found, but pip is not installed. Something went wrong while installing/building. Try '--build=python' as argument."
    fi
}

# Builds Python from source, using the specified version.
build_python() {
    local official_base_url latest_patch_version official_url temp_file temp_dir
    log_message "INFO: Building 'Python${PYTHON_VERSION}' from source. This may take some time ..."
    official_base_url="https://www.python.org/ftp/python/"

    latest_patch_version=$(curl -s "${official_base_url}" | grep -oP "${PYTHON_VERSION}\.[0-9]+/" | sort -V | tail -n 1 | sed 's:/$::')

    official_url="${official_base_url}${latest_patch_version}/Python-${latest_patch_version}.tgz"
    temp_file="/tmp/Python-${latest_patch_version}.tgz"
    temp_dir="/tmp/Python-${latest_patch_version}_temp"
    register_cleanup "${temp_file}" "${temp_dir}"

    if ! log curl -L -o "${temp_file}" "${official_url}"; then
        log_message "ERROR: Failed to download Python source from '${official_url}'."
    fi

    mkdir -p "${temp_dir}" || {
        log_message "ERROR: Failed to create '${temp_dir}'."
    }

    if ! tar -xf "${temp_file}" -C "${temp_dir}"; then
        log_message "ERROR: Failed to extract '${temp_file}'."
    fi

    cd "${temp_dir}/Python-${latest_patch_version}" || {
        log_message "ERROR: Failed to change directory."
    }
    log ./configure --enable-optimizations --with-ensurepip=install --prefix="${DEFAULT_OPTS[INSTALL_DIR]}/python"
    log make -j "$(nproc)"
    sudo_wrapper make altinstall
    cd "${PSYCHOPY_DIR}" || {
        log_message "ERROR: Failed to return to '${PSYCHOPY_DIR}'."
    }

    sudo_wrapper rm -rf "${temp_dir}" "${temp_file}"
    return 0
}

install_python_from_github() {
    local asset_name api_url github_api_header assets_json temp_file temp_dir github_download_url python_version_pattern latest_release_tag

    github_api_header="Accept: application/vnd.github.v3+json"
    latest_release_tag=$(curl -s -H "${github_api_header}" "https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest" | jq -r .tag_name)
    api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/tags/v${SCRIPT_VERSION}"
    assets_json=$(curl -s -H "${github_api_header}" "${api_url}")

    python_version_pattern="python-${PYTHON_VERSION}\.[0-9]+-${PROCESSOR_STRUCTURE}-${OS_VERSION}\.tar\.gz"
    asset_name=$(echo "${assets_json}" | jq -r '.assets // [] | .[].name' | grep -E "${python_version_pattern}" | sort -V | tail -n 1)

    # If no matching asset is found AND the script version is NOT the latest, check the latest release
    if [[ -z "${asset_name}" && "v${SCRIPT_VERSION}" != "${latest_release_tag}" ]]; then
        log_message "WARNING: No matching Python version found in 'v${SCRIPT_VERSION}'. Checking the latest release '${latest_release_tag}' ..."
        api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest"
        assets_json=$(curl -s -H "${github_api_header}" "${api_url}")
        asset_name=$(echo "${assets_json}" | jq -r '.assets // [] | .[].name' | grep -E "${python_version_pattern}" | sort -V | tail -n 1)
    fi

    if [ -z "${asset_name}" ]; then
        log_message "WARNING: No matching Python version found in 'v${SCRIPT_VERSION}' or latest release '${latest_release_tag}' for Python${PYTHON_VERSION}."
        return 1
    fi

    github_download_url=$(echo "${assets_json}" | jq -r --arg name "${asset_name}" '.assets // [] | .[] | select(.name == $name) | .browser_download_url')

    if [ -z "${github_download_url}" ]; then
        log_message "WARNING: Could not find a download URL for asset '${asset_name}'."
        return 1
    fi

    log_message "INFO: Downloading '${asset_name}' from GitHub ..."
    local download_path="/tmp/${asset_name}"
    local temp_dir="/tmp/${asset_name%.tar.gz}_temp"
    register_cleanup "${download_path}" "${temp_dir}"
    if log curl -L -o "${download_path}" "${github_download_url}"; then
        log_message "INFO: Successfully downloaded '${asset_name}' from GitHub release 'v${SCRIPT_VERSION}'. Making an altinstall ..."
        mkdir -p "${temp_dir}" || {
            log_message "WARNING: Failed to create '${temp_dir}'."
            return 1
        }

        if tar -xf "${download_path}" -C "${temp_dir}"; then
            cd "${temp_dir}" || {
                log_message "WARNING: Failed to change directory."
                return 1
            }
            sudo_wrapper make altinstall
            cd "${PSYCHOPY_DIR}" || {
                log_message "WARNING: Failed to return to '${PSYCHOPY_DIR}'."
                return 1
            }
            sudo_wrapper rm -rf "${temp_dir}" "${download_path}"
            return 0
        else
            log_message "WARNING: Failed to extract '${asset_name}'."
            sudo_wrapper rm -rf "${temp_dir}"
            return 1
        fi
    else
        log_message "WARNING: Failed to download from GitHub release."
        return 1
    fi
}

# Builds wxPython from source with the necessary build dependencies.
build_wxpython() {
    local tmp_size_gb

    log_message "INFO: Installing wxPython build dependencies. This might take a while ..."
    install_dependencies wxpython_deps

    # Check /tmp size and warn if â‰¤4GB
    tmp_size_gb=$(df -B1G --output=size /tmp 2>/dev/null | tail -n1 | tr -d ' ' || echo 0)
    [ "${tmp_size_gb}" -le 4 ] && log_message "WARNING: /tmp is only '${tmp_size_gb}GB'. wxPython build may fail. Please increase your '/tmp' size."

    log_message "INFO: Building wxPython ${WXPYTHON_VERSION} from source. This might take a while ..."
    if log "${PYTHON_VENV_COMMAND}" -m pip install --no-binary=wxpython --no-cache-dir --force-reinstall "wxpython==${WXPYTHON_VERSION}"; then
        log_message "INFO: Successfully built wxPython from source."
    else
        log_message "ERROR: Building wxPython from source failed."
    fi
}

# Attempts to install wxPython from a GitHub released wheel.
install_wxpython_from_github() {
    local api_url assets_json latest_release_tag github_api_header wheel_name renamed_wheel download_url python_version_major_minor

    github_api_header="Accept: application/vnd.github.v3+json"
    latest_release_tag=$(curl -s -H "${github_api_header}" "https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest" | jq -r .tag_name)
    api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/tags/v${SCRIPT_VERSION}"
    assets_json=$(curl -s -H "${github_api_header}" "${api_url}")

    python_version_major_minor=$(echo "${PYTHON_VERSION}" | awk -F. '{printf "%s%s", $1, $2}')
    wheel_name="wxPython-${WXPYTHON_VERSION}-cp${python_version_major_minor}-cp${python_version_major_minor}-${PROCESSOR_STRUCTURE}-${OS_VERSION}.whl"
    download_url=$(echo "${assets_json}" | jq -r --arg name "${wheel_name}" '.assets // [] | .[] | select(.name == $name) | .browser_download_url')

    # If no matching wheel is found AND the script version is NOT the latest, check the latest release
    if [[ -z "${download_url}" && "v${SCRIPT_VERSION}" != "${latest_release_tag}" ]]; then
        log_message "INFO: No matching wxPython wheel found in 'v${SCRIPT_VERSION}'. Checking the latest release '${latest_release_tag}' ..."
        api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest"
        assets_json=$(curl -s -H "${github_api_header}" "${api_url}")
        download_url=$(echo "${assets_json}" | jq -r --arg name "${wheel_name}" '.assets // [] | .[] | select(.name == $name) | .browser_download_url')
    fi

    if [ -z "${download_url}" ]; then
        log_message "WARNING: No matching wxPython wheel found in 'v${SCRIPT_VERSION}' or latest release '${latest_release_tag}' for 'wxPython ${WXPYTHON_VERSION}'."
        return 1
    fi

    log_message "INFO: Downloading '${wheel_name}' from GitHub ..."
    local download_path="/tmp/${wheel_name}"
    register_cleanup "${download_path}"
    if log curl -L -o "${download_path}" "${download_url}"; then
        log_message "INFO: Successfully downloaded wxPython wheel from GitHub release. Installing wxPython from '${wheel_name}' ..."
        renamed_wheel="${wheel_name%-"${OS_VERSION}".whl}.whl"
        mv "${download_path}" "${renamed_wheel}"
        if log "${PYTHON_VENV_COMMAND}" -m pip install "${renamed_wheel}"; then
            log_message "INFO: Installed wxPython from '${renamed_wheel}'"
            sudo_wrapper mkdir -p "${DEFAULT_OPTS[INSTALL_DIR]}/python/wx_wheels"
            sudo_wrapper chmod -R a+rX "${DEFAULT_OPTS[INSTALL_DIR]}/python/wx_wheels"
            sudo_wrapper mv "${renamed_wheel}" "${DEFAULT_OPTS[INSTALL_DIR]}/python/wx_wheels/"
            return 0
        else
            log_message "WARNING: Installing wxPython from '${renamed_wheel}' failed."
            rm "${renamed_wheel}"
            return 1
        fi
    else
        log_message "WARNING: Downloading '${wheel_name}' failed."
        return 1
    fi
}

# Creates desktop shortcuts for PsychoPy applications.
create_desktop_shortcut() {
    local desktop_shortcut desktop_dir psychopy_exec resources_dir desktop_content
    desktop_dir="${HOME}/.local/share/applications"
    psychopy_exec="${PSYCHOPY_DIR}/start_psychopy"
    resources_dir="${PSYCHOPY_DIR}/Resources"
    local shortcuts=()

    if ! desktop_shortcut="$(xdg-user-dir DESKTOP 2>/dev/null)"; then
        log_message "WARNING: xdg-user-dir not found. Desktop shortcut creation failed."
        return
    fi

    shortcuts+=(
        "--no-splash" "$(basename "${PSYCHOPY_DIR}")" "psychopy.png"
        "--builder --no-splash" "Builder $(basename "${PSYCHOPY_DIR}")" "builder.png"
        "--coder --no-splash" "Coder $(basename "${PSYCHOPY_DIR}")" "coder.png"
    )

    if [ ! -d "${desktop_shortcut}" ]; then
        log_message "WARNING: Desktop directory '${desktop_shortcut}' does not exist. Skipping shortcut creation."
        return
    fi

    sudo_wrapper mkdir -p "${resources_dir}"

    for ((i = 0; i < ${#shortcuts[@]}; i += 3)); do
        local exec_args="${shortcuts[i]}"
        local pretty_name="${shortcuts[i + 1]}"
        local icon_file="${shortcuts[i + 2]}"
        local icon_url="https://raw.githubusercontent.com/wieluk/psychopy_linux_installer/main/Resources/${icon_file}"
        local desktop_file="${desktop_shortcut}/${pretty_name}.desktop"
        local icon_path="${resources_dir}/${icon_file}"

        if curl --output /dev/null --silent --head --fail "${icon_url}"; then
            log curl -s -o "${icon_path}" "${icon_url}"
        else
            log_message "WARNING: Icon file '${icon_url}' not found, skipping ..."
        fi

        local icon_line=""
        [ -f "${icon_path}" ] && icon_line="Icon=${icon_path}"

        desktop_content=$(printf "%s\n" \
            "[Desktop Entry]" \
            "Version=1.0" \
            "Type=Application" \
            "Name=${pretty_name}" \
            "GenericName=PsychoPy Experiment Builder" \
            "Comment=Run PsychoPy ${PSYCHOPY_VERSION} on Python${PYTHON_VERSION} with ${exec_args}" \
            "Exec=${psychopy_exec} ${exec_args}" \
            "${icon_line}" \
            "Terminal=false" \
            "Categories=Education;Science;Development;" \
            "MimeType=application/x-psyexp;" \
            "Keywords=psychopy;experiment;builder;psyexp;design;" \
            "TryExec=${psychopy_exec}" \
            "StartupNotify=true" \
            "StartupWMClass=psychopy")

        sudo_wrapper sh -c "echo '${desktop_content}' > '${desktop_file}'"
        sudo_wrapper chmod +x "${desktop_file}"
        sudo_wrapper chown "${USER}" "${desktop_file}"
        command -v gio >/dev/null 2>&1 && gio set "${desktop_file}" metadata::trusted true

        sudo_wrapper ln -sf "${desktop_file}" "${desktop_dir}/${pretty_name}.desktop"
    done
    log_message "INFO: Desktop shortcuts created successfully."
}

# Adds the PsychoPy installation's bin directory to the PATH.
add_psychopy_to_path() {
    local name src target

    name="$(basename "${PSYCHOPY_DIR}")"
    src="${PSYCHOPY_DIR}/start_psychopy"
    target="/usr/local/bin/${name}"

    if [ -L "${target}" ] || [ ! -e "${target}" ]; then
        sudo_wrapper ln -sf "${src}" "${target}"
    else
        log_message "WARNING: Symlink Target exists and is not a symlink: '${target}'. Skipping symlink creation."
        return
    fi
    sudo_wrapper chmod +x "${target}"
    log_message "NOTE: To start PsychoPy from the system path, use: '$(basename "${PSYCHOPY_DIR}")'"
}

create_start_psychopy_wrapper() {
    local wrapper_path="${PSYCHOPY_DIR}/start_psychopy"
    local config_folder_block=""
    sudo_wrapper mkdir -p "${PSYCHOPY_DIR}/workspace"
    sudo_wrapper mkdir -p "${PSYCHOPY_DIR}/.psychopy3"

    if is_version_greater "${PSYCHOPY_VERSION}" "2025.1.1" || [ "${PSYCHOPY_VERSION}" = "git" ]; then
        config_folder_block=$(printf "%s\n" \
            "" \
            "# === Change this if you want to set a custom PsychoPy config folder ===" \
            "CONFIG_DIR=\"\${SCRIPT_DIR}\"" \
            "" \
            "if [ -d \"\${CONFIG_DIR}\" ]; then" \
            "    echo \"[start_psychopy] PsychoPy config folder: \${CONFIG_DIR}/.psychopy3\"" \
            "    CONFIG_ARG=\"--user-dir=\${CONFIG_DIR}\"" \
            "else" \
            "    echo \"[start_psychopy] WARNING: Config directory '\${CONFIG_DIR}' does not exist. Using default PsychoPy config location.\"" \
            "    CONFIG_ARG=\"\"" \
            "fi" \
            "")
    fi

    local wrapper_script
    wrapper_script=$(printf "%s\n" \
        "#!/bin/bash" \
        "# ================================================================================" \
        "#  PsychoPy Start Wrapper" \
        "#  This script launches PsychoPy from a virtual environment, setting up the" \
        "#  working directory and configuration folder." \
        "#  This script is placed in the top-level PsychoPy installation directory by default." \
        "#  Do not move it!" \
        "# ================================================================================" \
        "" \
        "SCRIPT_DIR=\"\$(dirname \"\$(readlink -f \"\$0\")\")\"" \
        "" \
        "# === Change this if you want to set a custom working directory ===" \
        "WORKSPACE_DIR=\"\${SCRIPT_DIR}/workspace\"" \
        "" \
        "if [ -d \"\${WORKSPACE_DIR}\" ]; then" \
        "    echo \"[start_psychopy] Working directory: \${WORKSPACE_DIR}\"" \
        "    cd \"\${WORKSPACE_DIR}\"" \
        "else" \
        "    echo \"[start_psychopy] WARNING: Workspace directory '\${WORKSPACE_DIR}' does not exist. Not changing directory.\"" \
        "fi" \
        "" \
        "${config_folder_block}" \
        "exec \"\${SCRIPT_DIR}/bin/psychopy\" \${CONFIG_ARG} \"\$@\""
    )

    sudo_wrapper sh -c "echo '${wrapper_script}' > '${wrapper_path}'"
    sudo_wrapper chmod +x "${wrapper_path}"
}

verify_installed_pip_versions() {
    local pip_extra_packages="$1"
    local mismatches=()
    local pkg req_version installed_version name version inst req
    declare -A installed_versions
    while read -r line; do
        if [[ "${line}" =~ ^([A-Za-z0-9._-]+)==(.+)$ ]]; then
            name="${BASH_REMATCH[1],,}"
            version="${BASH_REMATCH[2]}"
            installed_versions["${name}"]="${version}"
        fi
    done < <("${PYTHON_VENV_COMMAND}" -m pip list --format=freeze 2>/dev/null)

    IFS=',' read -ra PKG_LIST <<<"${pip_extra_packages}"
    for pkg_spec in "${PKG_LIST[@]}"; do
        if [[ "${pkg_spec}" =~ ^([A-Za-z0-9._-]+)==([0-9][A-Za-z0-9._-]*) ]]; then
            pkg="${BASH_REMATCH[1],,}"
            req_version="${BASH_REMATCH[2]}"
            installed_version="${installed_versions[${pkg}]}"
            if [ -z "${installed_version}" ]; then
                mismatches+=("${pkg}|${req_version}|not installed")
            elif [ "${installed_version}" != "${req_version}" ]; then
                mismatches+=("${pkg}|${req_version}|${installed_version}")
            fi
        fi
    done

    if [ ${#mismatches[@]} -ne 0 ]; then
        log_message "WARNING: Some pip package versions do not match requirements.txt."
        indent="                      "
        printf "${indent}%-20s | %-15s | %-15s\n" "Package" "Required" "Installed"
        printf "${indent}%s\n" "---------------------+-----------------+-----------------"
        for mismatch in "${mismatches[@]}"; do
            IFS='|' read -r pkg req inst <<<"${mismatch}"
            printf "${indent}%-20s | %-15s | %-15s\n" "${pkg}" "${req}" "${inst}"
        done
        printf "${indent}%s\n" "---------------------------------------------------------"
    fi
}

main() {
    local use_gui tmp_log_file final_log_file rerun_cmd pip_extra_packages limits_file
    PKG_MANAGER_PERMISSION=false
    PSYCHOPY_GIT_TAG=false
    TEMPORARY_SUDO_SETUP_DONE=false
    use_gui=false

    # Ensure /tmp exists and is writable
    if [ ! -d /tmp ]; then
        mkdir -p /tmp
        chmod 1777 /tmp
    fi
    if [ ! -w /tmp ]; then
        echo "ERROR: /tmp directory is not writable or does not exist. Please check your system permissions."
        exit 1
    fi

    tmp_log_file="/tmp/psychopy_linux_installer_$(date +%Y%m%d_%H%M%S).log"
    LOG_FILE="${tmp_log_file}"

    check_connection

    for arg in "${@}"; do
        if [[ "${arg}" == "--gui" ]]; then
            if [[ "${#}" -eq 1 ]]; then
                use_gui=true
            else
                log_message "ERROR: The --gui option must be used alone without any other arguments." nolog
            fi
            break
        fi
    done

    if ${use_gui}; then
        if ! command -v zenity &>/dev/null; then
            log_message "ERROR: zenity is not installed or not available in PATH. Cannot use GUI mode." nolog
        else
            show_gui
        fi
    else
        process_arguments "${@}"
    fi

    log_message "NOTE: Logging to temporary file: '${LOG_FILE}'"

    if [ -n "${REQUIREMENTS_FILE}" ]; then
        log_message "INFO: Parsing requirements file: '${REQUIREMENTS_FILE}' ..."
        parse_requirements_file "${REQUIREMENTS_FILE}"
    fi

    # Ensure defaults for unset variables
    for key in "${!DEFAULT_OPTS[@]}"; do
        if [ -z "${!key+x}" ]; then
            eval "${key}='${DEFAULT_OPTS[${key}]}'"
        fi
    done

    VENV_NAME=${VENV_NAME//[[:space:]]/_}
    if [[ "${INSTALL_DIR}" == "${DEFAULT_OPTS[INSTALL_DIR]}" && "${VENV_NAME,,}" == "python" ]]; then
        log_message "ERROR: The virtual environment name cannot be 'python' (case-insensitive) when installing into the default directory ('${DEFAULT_OPTS[INSTALL_DIR]}')." nolog
    fi

    if ${use_gui}; then
        rerun_cmd=$(create_rerun_command)
        log_message "NOTE: To re-run the installer with the current --gui settings, use: '${rerun_cmd}'"
        echo
    fi

    # Detect OS version, architecture and script version
    detect_os_version
    PROCESSOR_STRUCTURE=$(uname -s | tr '[:upper:]' '[:lower:]')_$(uname -m)
    SCRIPT_VERSION=$(grep -m 1 'Version:' "$0" | sed 's/[^0-9.]//g')
    log_message "INFO: Initiating PsychoPy-${PSYCHOPY_VERSION} installation using psychopy_linux_installer(${SCRIPT_VERSION}) on ${OS_VERSION_FULL} (${PROCESSOR_STRUCTURE})."

    # Detect package manager
    PKG_MANAGER=$(detect_package_manager)

    # Update package manager
    log_message "INFO: Updating '${PKG_MANAGER}' package manager."
    update_package_manager "${PKG_MANAGER}"

    # Install basic dependencies
    log_message "INFO: Installing 'git', 'curl', and 'jq'."
    install_dependencies script_deps

    # Check for script update
    if [ "${NON_INTERACTIVE}" = false ]; then
        check_script_update
    fi

    # Determine PsychoPy version to install
    if [ "${PSYCHOPY_VERSION}" == "latest" ]; then
        get_latest_pypi_version "psychopy" PSYCHOPY_VERSION
    elif [ "${PSYCHOPY_VERSION}" != "git" ]; then
        check_pypi_for_version psychopy "${PSYCHOPY_VERSION}"
    fi

    # Set up PsychoPy installation directory
    INSTALL_DIR="${INSTALL_DIR/#\~/${HOME}}"
    INSTALL_DIR="${INSTALL_DIR%/}"
    if [ -n "${VENV_NAME}" ]; then
        PSYCHOPY_DIR="${INSTALL_DIR}/${VENV_NAME}"
    else
        PSYCHOPY_DIR="${INSTALL_DIR}/PsychoPy-${PSYCHOPY_VERSION}-Python${PYTHON_VERSION}"
    fi

    if [ -d "${PSYCHOPY_DIR}" ]; then
        if [ "${FORCE_OVERWRITE}" = true ]; then
            log_message "WARNING: Directory '${PSYCHOPY_DIR}' already exists. Overwriting ..."
            sudo_wrapper rm -rf "${PSYCHOPY_DIR}"
            if [ -d "${PSYCHOPY_DIR}" ]; then
                log_message "ERROR: Failed to delete '${PSYCHOPY_DIR}'. Check permissions or remove manually."
            fi
            sudo_wrapper mkdir -p "${PSYCHOPY_DIR}"
        else
            log_message "ERROR: Directory '${PSYCHOPY_DIR}' already exists. Use the --force-overwrite flag to overwrite."
        fi
    else
        log_message "INFO: Creating PsychoPy directory at '${PSYCHOPY_DIR}' ..."
        sudo_wrapper mkdir -p "${PSYCHOPY_DIR}"
    fi
    sudo_wrapper chmod -R a+rX "${PSYCHOPY_DIR}"
    [ -w "${PSYCHOPY_DIR}" ] || sudo_wrapper chown "${USER}" "${PSYCHOPY_DIR}"

    if ! [ -w "${PSYCHOPY_DIR}" ] || ! cd "${PSYCHOPY_DIR}"; then
        log_message "ERROR: Failed to access or change directory to '${PSYCHOPY_DIR}'."
    fi

    # Transition logs into psychopy_dir while keeping the same filename
    final_log_file="${PSYCHOPY_DIR}/$(basename "${tmp_log_file}")"

    if [ -f "${tmp_log_file}" ]; then
        if mv "${tmp_log_file}" "${final_log_file}"; then
            LOG_FILE="${final_log_file}"
        else
            log_message "WARNING: Failed to move log file to installation directory. Log will remain at '${tmp_log_file}'."
        fi
    fi
    log_message "NOTE: Installation directory set. Log file moved to: '${LOG_FILE}'."

    # Install PsychoPy dependencies
    log_message "INFO: Installing PsychoPy dependencies. This might take a while ..."
    install_dependencies psychopy_deps

    # Install python and create venv
    if [ "${BUILD_PYTHON}" = true ] || ! check_python_in_package_manager; then
        if [ "${BUILD_PYTHON}" = true ]; then
            log_message "INFO: Installing Python build dependencies ..."
            install_dependencies python_build_deps
            build_python
        else
            if [ -x "${DEFAULT_OPTS[INSTALL_DIR]}/python/bin/python${PYTHON_VERSION}" ]; then
                log_message "INFO: 'Python${PYTHON_VERSION}' is already installed in '${DEFAULT_OPTS[INSTALL_DIR]}/python'. Skipping installation."
            else
                log_message "INFO: Installing Python build dependencies ..."
                install_dependencies python_build_deps
                if install_python_from_github; then
                    :
                else
                    build_python
                fi
            fi
        fi

        check_python_env "${DEFAULT_OPTS[INSTALL_DIR]}/python/bin/python${PYTHON_VERSION}"
        if [ ! -x "${DEFAULT_OPTS[INSTALL_DIR]}/python/bin/python${PYTHON_VERSION}" ]; then
            log_message "ERROR: 'python${PYTHON_VERSION}' not found in '${DEFAULT_OPTS[INSTALL_DIR]}/python'. Something went wrong while installing/building. You can try '--build=python'."
        fi
        export PATH=${DEFAULT_OPTS[INSTALL_DIR]}/python/bin:$PATH
        "${DEFAULT_OPTS[INSTALL_DIR]}"/python/bin/python"${PYTHON_VERSION}" -m venv "${PSYCHOPY_DIR}"
    else
        log_message "INFO: 'Python${PYTHON_VERSION}' can be installed via ${PKG_MANAGER}. Installing ..."
        install_dependencies python_with_venv
        check_python_env "python${PYTHON_VERSION}"
        python"${PYTHON_VERSION}" -m venv "${PSYCHOPY_DIR}"
    fi

    log_message "INFO: Successfully created 'Python${PYTHON_VERSION}' venv in '${PSYCHOPY_DIR}'."
    PYTHON_VENV_COMMAND="${PSYCHOPY_DIR}/bin/python"
    check_python_env "${PYTHON_VENV_COMMAND}"

    # Upgrade pip and install required Python packages
    log_message "INFO: Upgrading 'pip', 'distro', 'sip', 'six', 'psychtoolbox', 'attrdict', 'setuptools', 'wheel' ..."
    log "${PYTHON_VENV_COMMAND}" -m pip install -U pip distro sip six psychtoolbox setuptools wheel
    if [[ "${PYTHON_VERSION}" == "3.8" || "${PYTHON_VERSION}" == "3.9" ]]; then
        log "${PYTHON_VENV_COMMAND}" -m pip install -U attrdict
    elif [[ "${PYTHON_VERSION}" == "3.10" ]]; then
        log "${PYTHON_VENV_COMMAND}" -m pip install -U attrdict3
    fi

    # Determine wxPython version and install it
    log_message "INFO: Installing wxpython '${WXPYTHON_VERSION}' ..."
    if [ "${WXPYTHON_VERSION}" = "latest" ]; then
        get_latest_pypi_version "wxPython" WXPYTHON_VERSION
    elif [ "${WXPYTHON_VERSION}" != "git" ]; then
        check_pypi_for_version wxpython "${WXPYTHON_VERSION}"
    fi

    if [ "${WXPYTHON_VERSION}" = "git" ]; then
        log_message "INFO: Installing wxPython build dependencies. This might take a while ..."
        install_dependencies wxpython_deps
        log_message "INFO: Building wxPython from git. This might take a while ..."
        log "${PYTHON_VENV_COMMAND}" -m pip install git+https://github.com/wxWidgets/Phoenix
    elif [ "${BUILD_WX}" = true ]; then
        build_wxpython
    else
        if log "${PYTHON_VENV_COMMAND}" -m pip install --only-binary=:all: --find-links "${DEFAULT_OPTS[INSTALL_DIR]}/python/wx_wheels/" "wxpython==${WXPYTHON_VERSION}"; then
            log_message "INFO: Successfully installed wxPython '${WXPYTHON_VERSION}' from local wheel."
        elif log "${PYTHON_VENV_COMMAND}" -m pip install --only-binary=:all: --find-links "https://extras.wxpython.org/wxPython4/extras/linux/gtk3/${OS_VERSION_LINK}/" "wxPython==${WXPYTHON_VERSION}"; then
            log_message "INFO: Successfully installed wxPython '${WXPYTHON_VERSION}' from extras.wxpython.org."
        elif install_wxpython_from_github; then
            :
        else
            build_wxpython
        fi
    fi

    if ! "${PYTHON_VENV_COMMAND}" -m pip show wxPython &>/dev/null; then
        log_message "ERROR: wxPython is not installed. Something went wrong during the installation. You can try '--build=wxpython'."
    fi

    # Install numpy<2 if PsychoPy version is less than 2024.2.0
    if is_version_greater "2024.2.0" "${PSYCHOPY_VERSION}" || [[ "${PYTHON_VERSION}" == "3.9" ]]; then
        log_message "INFO: Installing numpy<2"
        log "${PYTHON_VENV_COMMAND}" -m pip install "numpy<2"
    fi

    # Install additional packages from requirements file and flag
    pip_extra_packages="${ADDITIONAL_PACKAGES}${ADDITIONAL_PACKAGES:+,}${REQUIREMENTSFILE_PACKAGES}"

    [ -n "${pip_extra_packages}" ] && install_pip_packages_with_fallback "${pip_extra_packages}"

    # Install PsychoPy
    log_message "INFO: Installing PsychoPy '${PSYCHOPY_VERSION}' ..."
    if [ "${PSYCHOPY_VERSION}" == "git" ]; then
        log "${PYTHON_VENV_COMMAND}" -m pip install git+https://github.com/psychopy/psychopy.git@dev
    elif [ "${PSYCHOPY_GIT_TAG}" = "true" ]; then
        log "${PYTHON_VENV_COMMAND}" -m pip install "git+https://github.com/psychopy/psychopy.git@${PSYCHOPY_VERSION}"
    else
        log "${PYTHON_VENV_COMMAND}" -m pip install psychopy=="${PSYCHOPY_VERSION}"
    fi

    if ! "${PYTHON_VENV_COMMAND}" -m pip show psychopy &>/dev/null; then
        log_message "ERROR: PsychoPy installation failed."
    fi

    # Install some basic fonts for PsychoPy
    log_message "INFO: Installing basic fonts for PsychoPy."
    install_dependencies fonts

    # Check if psychopy group exists, create if not
    if getent group psychopy >/dev/null; then
        log_message "INFO: Group 'psychopy' already exists."
    else
        sudo_wrapper groupadd psychopy
        log_message "INFO: Group 'psychopy' created."
    fi

    # Check if user is in group, add if not
    if id -nG "${USER}" | grep -qw psychopy; then
        log_message "INFO: User '${USER}' is already in the 'psychopy' group."
    else
        sudo_wrapper usermod -a -G psychopy "${USER}"
        log_message "INFO: User '${USER}' added to 'psychopy' group."
    fi

    # Check if limits file exists before writing
    limits_file="/etc/security/limits.d/99-psychopylimits.conf"
    if [ -f "${limits_file}" ]; then
        log_message "INFO: Limits file '${limits_file}' already exists. Skipping overwrite."
    else
        sudo_wrapper sh -c 'echo "@psychopy - nice -20\n@psychopy - rtprio 50\n@psychopy - memlock unlimited" > /etc/security/limits.d/99-psychopylimits.conf'
        log_message "INFO: Limits file '${limits_file}' created."
        log_message "NOTE: A system reboot is necessary to apply the security limits."
    fi

    # Compare installed package versions with requested versions
    if [ -n "${pip_extra_packages}" ]; then
        verify_installed_pip_versions "${pip_extra_packages}"
    fi

    # Remove .psychopy3
    if [ "${REMOVE_PSYCHOPY_SETTINGS}" = true ]; then
        if [ -d "${HOME}/.psychopy3" ]; then
            log_message "INFO: Removing existing '.psychopy3' directory."
            sudo_wrapper rm -rf "${HOME}/.psychopy3"
            if [ -d "${HOME}/.psychopy3" ]; then
                log_message "WARNING: Failed to delete '${HOME}/.psychopy3'. Check permissions or remove manually."
            fi
        fi
    elif [ "${NON_INTERACTIVE}" = false ]; then
        if [ -d "${HOME}/.psychopy3" ]; then
            echo
            read -r -p "Do you want to remove the PsychoPy settings folder at '${HOME}/.psychopy3'? Keeping it may cause conflicts with plugins or user-installed pip packages.

            [y] Yes
            [n] No

            Enter your choice [y/n]: " response
            echo

            if [[ "${response}" =~ ^[Yy]$ ]]; then
                log_message "INFO: Removing existing '.psychopy3' directory."
                sudo_wrapper rm -rf "${HOME}/.psychopy3"
                if [ -d "${HOME}/.psychopy3" ]; then
                    log_message "WARNING: Failed to delete '${HOME}/.psychopy3'. Check permissions or remove manually."
                fi
            else
                log_message "INFO: Skipped removing '.psychopy3' directory."
            fi
        fi
    fi

    # Create start wrapper script
    create_start_psychopy_wrapper

    # Create desktop shortcut
    if [ "${DISABLE_SHORTCUT}" = false ]; then
        create_desktop_shortcut
    fi

    # Add PsychoPy to PATH
    if [ "${DISABLE_PATH}" = false ]; then
        add_psychopy_to_path
    fi

    log_message "NOTE: To start PsychoPy using the absolute path, run: '${PSYCHOPY_DIR}/start_psychopy'"

    if "${PSYCHOPY_DIR}/bin/psychopy" -v &>/dev/null; then
        if "${PSYCHOPY_DIR}/start_psychopy" -v &>/dev/null; then
            log_message "INFO: PsychoPy installation completed successfully!"
        else
            log_message "ERROR: PsychoPy wrapper script verification failed!"
        fi
    else
        log_message "ERROR: PsychoPy binary verification failed!"
    fi
}

main "${@}"
