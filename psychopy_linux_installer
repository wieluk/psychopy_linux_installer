#!/bin/bash
# ==============================================================================
#  Title:         psychopy_linux_installer
#  Description:   This script installs PsychoPy with specified versions of
#                 Python, wxPython, and optional packages.
#  Author:        Lukas Wiertz
#  Date:          2025-02-28
#  Version:       1.5.1
#  License:       GNU General Public License v3.0
# ==============================================================================

# Define default values in an associative array
declare -A default_opts=(
    [psychopy_version]="latest"
    [python_version]="3.10"
    [wxpython_version]="4.2.2"
    [build_python]=false
    [build_wx]=false
    [install_dir]="$HOME"
    [venv_name]=""
    [additional_packages]=""
    [sudo_mode]="ask"
    [disable_shortcut]=false
    [disable_path]=false
    [non_interactive]=false
    [force_overwrite]=false
    [verbose]=false
)

show_help() {
    cat << EOF
Usage: ./psychopy_linux_installer [options]
Options:
  --psychopy-version=VERSION                    Specify PsychoPy version (default: ${default_opts[psychopy_version]}).
  --python-version=3.8|3.9|3.10                 Specify Python version (default: ${default_opts[python_version]}).
  --wxpython-version=VERSION                    Specify wxPython version (default: ${default_opts[wxpython_version]}).
  --requirements-file=FILE                      Specify a requirements.txt file to define dependencies.
  --build=[python|wxpython|both]                Build Python and/or wxPython from source instead of downloading. Not recommended, only use if installation doesnâ€™t work as expected.
  --install-dir=DIR                             Specify installation directory (default: "${default_opts[install_dir]}").
  --venv-name=NAME                              Specify a custom name for the virtual environment folder. If omitted, a versioned subdirectory will be used by default.
  --additional-packages=PACKAGES                Specify additional pip packages to install. Format: package1==version,package2. No version is latest.
  --sudo-mode=[ask|auto|error|continue|force]   Control sudo usage. ask: confirm, auto: auto-confirm, error: exit if sudo needed, continue: continue without sudo, force: use sudo directly (default: ${default_opts[sudo_mode]}).
  --disable-shortcut                            Disable desktop shortcut creation.
  --non-interactive                             Run the installer without user interaction. Sets sudo-mode to auto if not set.
  --disable-path                                Disable adding psychopy to system path.
  --gui                                         Launches the installer in GUI mode, allowing you to set arguments interactively. Any arguments provided via the command line will be ignored while in GUI mode.
  -f, --force                                   Force overwrite of existing installation directory.
  -v, --verbose                                 Enable verbose output.
  -h, --help                                    Show this help message.
EOF
}

# Logging function for verbose output
log() {
    if [ "$verbose" = true ]; then
        "$@"
    else
        "$@" >/dev/null 2>&1
    fi
    return $?
}

# Function to print log messages with timestamp and color-coded severity
log_message() {
    local reset="\033[0m" green="\033[32m" yellow="\033[33m" red="\033[31m" timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Disable colors if not a terminal (e.g., redirected output)
    if [[ ! -t 1 ]]; then
        reset=""; green=""; yellow=""; red=""
    fi

    case "$1" in
        Info:*)    printf "%s - %b%s%b\n" "$timestamp" "$green" "$1" "$reset" ;;
        Warning:*) printf "%s - %b%s%b\n" "$timestamp" "$yellow" "$1" "$reset" ;;
        Error:*)   printf "%s - %b%s%b\n" "$timestamp" "$red" "$1" "$reset" ;;
        *)         printf "%s - %s\n" "$timestamp" "$1" ;;  # Default (no color)
    esac
}

# Function to parse requirements.txt
parse_requirements_file() {
    local file="$1"
    local -A package_versions
    local -A package_operators

    if [ ! -f "$file" ] || [ ! -s "$file" ] || [ ! -r "$file" ]; then
        log_message "Error: File '$file' is not accessible or empty."
        exit 1
    fi

    while IFS= read -r line; do
        if [[ "$line" =~ ^# ]] || [[ -z "$line" ]]; then
            continue
        fi

        if [[ "$line" =~ ^([A-Za-z0-9._-]+)[[:space:]]*(>=|<=|==|~=|!=|>|<)[[:space:]]*([0-9][A-Za-z0-9._-]*) ]]; then
            package_name="${BASH_REMATCH[1],,}"
            operator="${BASH_REMATCH[2]}"
            package_version="${BASH_REMATCH[3]}"

            if [[ -n "${package_versions[$package_name]}" ]]; then
                current_version="${package_versions[$package_name]}"
                if [[ "$operator" == "==" || "${package_operators[$package_name]}" != "==" ]]; then
                    package_versions["$package_name"]="$package_version"
                    package_operators["$package_name"]="$operator"
                fi
            else
                package_versions["$package_name"]="$package_version"
                package_operators["$package_name"]="$operator"
            fi
        fi
    done < "$file"

    backup_additional_packages=$(for pkg in "${!package_versions[@]}"; do
        if [[ "$pkg" != "wxpython" && "$pkg" != "psychopy" && "$pkg" != "pywin32" && "$pkg" != "pypiwin32" && "$pkg" != "pywinhook" ]]; then
            echo "$pkg${package_operators[$pkg]}${package_versions[$pkg]}"
        fi
    done | tr '\n' ',' | sed 's/,$//')

    python_version=$(grep -i -E '^# Python version:' "$file" | cut -d':' -f2 | xargs | cut -d'.' -f1,2 | tr -d '[:space:]' || true)
    wxpython_version="${package_versions["wxpython"]:-}"
    psychopy_version="${package_versions["psychopy"]:-}"

    [[ -z "$python_version" ]] && log_message "Warning: Python version not specified in requirements.txt, using default."
    [[ -z "$wxpython_version" ]] && log_message "Warning: wxPython version not specified in requirements.txt, using default."

    if [ -z "$psychopy_version" ]; then
        log_message "Warning: PsychoPy version not specified in requirements.txt, using default."
        backup_additional_packages="${backup_additional_packages:+$backup_additional_packages,}psychopy"
    else
        backup_additional_packages="${backup_additional_packages:+$backup_additional_packages,}psychopy==$psychopy_version"
    fi

    # Adjust Linux dependencies
    for pkg in pyglet python-vlc; do
        pkg_lower="${pkg,,}"
        if [[ -n "${package_versions[$pkg_lower]}" ]]; then
            version="${package_versions[$pkg_lower]}"
            backup_additional_packages=${backup_additional_packages//"$pkg_lower${package_operators[$pkg_lower]}$version"/"$pkg_lower>=$version"}
        fi
    done
}

# Wrapper function to handle sudo requests and permissions dynamically
sudo_wrapper() {
    local error_output exit_code
    local command=("$@")
    local is_pkg_manager_command=false

    needs_sudo() {
        local exit_code="$1"
        local error_output="$2"

        case $exit_code in
            0) return 1 ;;
            1|2|5|10|13|77|100|126|127) return 0 ;;
            *)
                log_message "Warning: Unhandled exit code $exit_code. Error output: $error_output. Trying to continue ..."
                return 1 ;;
        esac
    }

    setup_temporary_sudo_timeout() {
        if [ "$temporary_sudo_setup_done" = true ]; then
            return
        fi
        temp_sudoers="/etc/sudoers.d/temporary_timeout"
        trap 'echo; log_message "Info: Removing temporary sudoers file ($temp_sudoers) to restore original sudoers configuration."; sudo_wrapper rm -f "$temp_sudoers"' EXIT
        temporary_sudo_setup_done=true
        log_message "Info: Setting temporary sudo timeout to 300 minutes..."
        sudo_wrapper sh -c "echo 'Defaults        timestamp_timeout=300' > $temp_sudoers"
        sudo_wrapper chmod 440 $temp_sudoers
    }

    handle_sudo_request() {
        local response
        local command=("$@")

        case "$sudo_mode" in
            ask)
                if $is_pkg_manager_command; then
                    log_message "Warning: Command '${command[*]}' failed with '${error_output}'."
                    read -r -p "Retry with sudo for this and all future $pkg_manager commands(r), continue(c), quit(q), or auto sudo when needed(a)? [r/c/q/a] " response
                else
                    log_message "Warning: Command '${command[*]}' failed with '${error_output}'."
                    read -r -p "Retry with sudo(r), continue without sudo(c), quit(q), or auto sudo when needed(a)? [r/c/q/a] " response
                fi

                case "$response" in
                    [Rr])
                        if $is_pkg_manager_command; then
                            pkg_manager_permission=true
                        fi
                        log_message "Info: Retrying ${command[*]} with sudo ..."
                        log sudo "${command[@]}"
                        ;;
                    [Cc])
                        ;;
                    [aA])
                        sudo_mode=auto
                        setup_temporary_sudo_timeout
                        log_message "Info: Retrying ${command[*]} with sudo and setting sudo-mode=auto ..."
                        log sudo "${command[@]}"
                        ;;
                    *)
                        log_message "Info: Exiting."
                        exit 1
                        ;;
                esac
                ;;
            auto)
                setup_temporary_sudo_timeout
                if $is_pkg_manager_command; then
                    pkg_manager_permission=true
                fi
                log log_message "Warning: Command '${command[*]}' failed with: '${error_output}'. Using sudo..."
                log sudo "${command[@]}"
                ;;
            continue)
                log log_message "Warning: Command '${command[*]}' failed with: '${error_output}'. Continuing without sudo..."
                ;;
            error)
                log_message "Error: Command '${command[*]}' failed with '${error_output}'. Sudo is required, but mode is set to 'error'."
                exit 1
                ;;
        esac
    }

    is_pkg_manager_command=$([ "$1" == "$pkg_manager" ] && echo true || echo false)

    if [[ "$sudo_mode" == "force" || ( "$is_pkg_manager_command" == true && "$pkg_manager_permission" == true ) ]]; then
        log sudo "${command[@]}"
        return
    fi

    error_output=$("${command[@]}" 2>&1)
    exit_code=$?

    if needs_sudo "$exit_code" "$error_output"; then
        handle_sudo_request "${command[@]}"
    fi
}

# Function to check for updates
check_for_updates() {
    local latest_url="https://github.com/wieluk/psychopy_linux_installer/releases/latest/download/psychopy_linux_installer"
    local current_version latest_version

    # Extract version information from the current and latest scripts.
    current_version=$(grep -m 1 'Version:' "$0" | sed 's/[^0-9.]//g')
    latest_version=$(curl -sL "$latest_url" | grep -m 1 'Version:' | sed 's/[^0-9.]//g')

    if version_greater_than "$latest_version" "$current_version"; then
        echo -e "\nA new version ($latest_version) of the installer script is available."
        echo "ðŸ”¹ Repository: https://github.com/wieluk/psychopy_linux_installer"
        echo "ðŸ”¹ Releases:   https://github.com/wieluk/psychopy_linux_installer/releases"
        echo

        local script_path
        script_path=$(readlink -f "$0")

        read -r -p "Would you like to update? (y/n) " response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            log_message "Info: Updating to version $latest_version..."

            # Download and replace the current script with the latest release.
            if curl -sLo "$script_path" "$latest_url"; then
                log_message "Info: Update completed successfully."
            else
                log_message "Error: Failed to download the update."
                return 1
            fi

            # Build a re-run command that only includes options differing from their defaults.
            local cmd="$script_path"

            for key in "${!default_opts[@]}"; do
                [[ "$key" == "build_python" || "$key" == "build_wx" ]] && continue
                current_value="${!key}"
                default_value="${default_opts[$key]}"
                if [[ "$current_value" != "$default_value" ]]; then
                    if [[ "$current_value" == "true" ]] && [[ "$default_value" == "false" ]]; then
                        cmd+=" --${key//_/-}"
                    else
                        cmd+=" --${key//_/-}=$current_value"
                    fi
                fi
            done

            if [[ "$build_python" == true && "$build_wx" == true ]]; then
                cmd+=" --build=both"
            elif [[ "$build_python" == true ]]; then
                cmd+=" --build=python"
            elif [[ "$build_wx" == true ]]; then
                cmd+=" --build=wxpython"
            fi

            if [ -n "$requirements_file" ]; then
                cmd+=" --requirements-file=$requirements_file"
            fi

            echo
            echo "To re-run the installer with the current settings, use:"
            echo "$cmd"
            exit 0
        fi
    fi
}

# Function to detect the OS version
detect_os_version() {
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        if [ -n "$ID" ] && [ -n "$VERSION_ID" ]; then
            major_version=$(echo "$VERSION_ID" | cut -d. -f1)
            echo "$ID-$major_version"
            return
        fi
    fi

    if command -v lsb_release > /dev/null 2>&1; then
        version=$(lsb_release -sr | cut -d. -f1)
        echo "$(lsb_release -si)-$version"
        return
    fi

    log_message "Warning: Unable to detect OS version."
    echo "unknown"
    return
}

# Function to detect the package manager for the OS
detect_package_manager() {
    if command -v apt-get > /dev/null 2>&1; then
        echo "apt-get"
    elif command -v yum > /dev/null 2>&1; then
        echo "yum"
    elif command -v dnf > /dev/null 2>&1; then
        echo "dnf"
    elif command -v pacman > /dev/null 2>&1; then
        echo "pacman"
    elif command -v zypper > /dev/null 2>&1; then
        echo "zypper"
    else
        log_message "Error: No compatible package manager found. Exiting."
        exit 1
    fi
}

# Function to update the package manager
update_package_manager() {
    case $pkg_manager in
        apt-get) sudo_wrapper apt-get update -qq ;;
        yum) sudo_wrapper yum makecache -q ;;
        dnf) sudo_wrapper dnf makecache -q ;;
        pacman) log_message "Warning: Skipping 'pacman -Syu' to avoid unintended system upgrades. If you encounter a lot of 'package not found' errors, manually run 'sudo pacman -Syu' to update your package database, then rerun this script." ;;
        zypper) sudo_wrapper zypper refresh ;;
        *) log_message "Error: No compatible package manager found. Exiting."; exit 1 ;;
    esac
}

# Function to check if a package is available
filter_existing_packages() {
    local filtered_packages=()

    for package in "$@"; do
        # Skip conficting packages for specific OS versions
        case "$os_version" in
            ubuntu-24) [[ "$package" == "libwebkit2gtk-4.0-dev" ]] && continue ;;
            ubuntu-20) [[ "$package" == "libwebkit2gtk-4.1-dev" ]] && continue ;;
            debian-11) [[ "$package" == "libwebkit2gtk-4.1-dev" ]] && continue ;;
            pop-22) [[ "$package" == "pulseaudio" ]] && continue ;;
            fedora-39|fedora-40) [[ "$package" == "libxcb-xinerama" || "$package" == "pulseaudio" ]] && continue ;;
            rocky-9|centos-9) [[ "$package" == "libxcb-xinerama" || "$package" == "pulseaudio" || "$package" == "portaudio-devel" ]] && continue ;;
            linuxmint-22) [[ "$package" == "libwebkit2gtk-4.0-dev" ]] && continue ;;
            manjarolinux-25) [[ "$package" == "pulseaudio-utils" || "$package" == "pulseaudio" ]] && continue ;;
        esac

        case "$pkg_manager" in
            apt-get)
                if apt-cache show "$package" &>/dev/null; then
                    filtered_packages+=("$package")
                fi
                ;;
            yum|dnf)
                if $pkg_manager info "$package" &>/dev/null; then
                    filtered_packages+=("$package")
                fi
                ;;
            pacman)
                if pacman -Si "$package" &>/dev/null; then
                    filtered_packages+=("$package")
                fi
                ;;
            zypper)
                if zypper search --match-exact "$package" &>/dev/null; then
                    filtered_packages+=("$package")
                fi
                ;;
        esac
    done
    echo "${filtered_packages[@]}"
}

# Function to install packages using the package manager
install_packages() {
    local packages=("$@")

    # Try batch install first
    local available_packages
    available_packages=$(filter_existing_packages "${packages[@]}")

    # Using grep to compute the difference available_packages
    diff=$(printf "%s\n" "${packages[@]}" | grep -vxFf <(echo "$available_packages" | tr ' ' '\n') | paste -sd, -)
    [ -n "$diff" ] && log_message "Warning: The following packages are not available and will be skipped: $diff"

    if [[ -z "$available_packages" ]]; then
        log_message "No valid packages found for installation."
        return
    fi

    if case $pkg_manager in
        apt-get) sudo_wrapper apt-get install -y -qq ${available_packages[@]} ;;
        yum) sudo_wrapper yum install -y -q ${available_packages[@]} ;;
        dnf) sudo_wrapper dnf install -y -q ${available_packages[@]} ;;
        pacman) sudo_wrapper pacman -S --needed --noconfirm ${available_packages[@]} ;;
        zypper) sudo_wrapper zypper install -y ${available_packages[@]} ;;
        *) log_message "Error: No compatible package manager found."; exit 1 ;;
    esac; then
        return 0
    else
        log_message "Warning: Batch installation failed. Falling back to per-package installation. This might take sometime ..."
    fi

    # If batch install fails, fallback to installing packages one by one
    for package in "${packages[@]}"; do
        case $pkg_manager in
            apt-get) sudo_wrapper apt-get install -y -qq "$package" || log_message "Warning: Package $package not found, skipping." ;;
            yum) sudo_wrapper yum install -y -q "$package" || log_message "Warning: Package $package not found, skipping." ;;
            dnf) sudo_wrapper dnf install -y -q "$package" || log_message "Warning: Package $package not found, skipping." ;;
            pacman) sudo_wrapper pacman -S --needed --noconfirm "$package" || log_message "Warning: Package $package not found, skipping." ;;
            zypper) sudo_wrapper zypper install -y "$package" || log_message "Warning: Package $package not found, skipping." ;;
            *) log_message "Error: No compatible package manager found."; exit 1 ;;
        esac
    done
}

# Function to install different types of dependencies
install_dependencies() {
    local dep_type="$1"
    local dependencies=()

    case $pkg_manager in
        apt-get)
            script_deps=(curl git jq)
            psychopy_deps=(libasound2-dev libegl1-mesa-dev libglib2.0-dev libgtk-3-dev libnotify4 libusb-1.0-0-dev libwebkit2gtk-4.0-dev libwebkit2gtk-4.1-dev libxcb-cursor0 libxcb-xinerama0 libxkbcommon-x11-0 libsdl2-dev libglu1-mesa-dev ttf-mscorefonts-installer portaudio19-dev pulseaudio pulseaudio-utils)
            python_build_deps=(build-essential libbz2-dev libffi-dev libreadline-dev libsqlite3-dev libssl-dev make xz-utils zlib1g-dev)
            wxpython_deps=(freeglut3-dev g++ gstreamer1.0-plugins-base gstreamer1.0-tools gstreamer1.0-x libgtk2.0-dev libjpeg-dev libnotify-dev libpng-dev libsm-dev libtiff-dev make)
            python_with_venv=(python3 python3-dev python3-pip python3-venv)
            ;;
        yum|dnf)
            script_deps=(curl git jq)
            psychopy_deps=(alsa-lib-devel gtk3-devel libnotify mesa-libEGL-devel mesa-libGLU-devel msttcore-fonts-installer portaudio-devel pulseaudio pulseaudio-utils SDL2-devel webkit2gtk3-devel webkit2gtk4.0-devel libusb1-devel)
            python_build_deps=(bzip2-devel gcc libffi-devel make openssl-devel readline-devel sqlite-devel xz-devel zlib-devel)
            wxpython_deps=(freeglut-devel gcc-c++ gstreamer1-devel gtk2-devel libSM-devel libjpeg-devel libjpeg-turbo-devel libnotify-devel libpng-devel libtiff-devel make glib2-devel)
            python_with_venv=(python3 python3-devel python3-pip python3-venv)
            ;;
        pacman)
            script_deps=(curl git jq)
            psychopy_deps=(alsa-lib gtk3 libnotify libusb mesa portaudio pulseaudio pulseaudio-utils SDL2 webkit2gtk xcb-util-cursor libxcb glu)
            python_build_deps=(base-devel bzip2 libffi make openssl readline sqlite xz zlib)
            wxpython_deps=(freeglut gcc glib2 gstreamer gtk2 libjpeg libpng libsm libtiff make mesa)
            python_with_venv=(python python-pip python-virtualenv)
            ;;
        zypper)
            script_deps=(curl git jq)
            psychopy_deps=(alsa-devel gtk3-devel libnotify4 libusb-1_0-devel libxcb-xinerama0 msttcore-fonts-installer portaudio-devel pulseaudio pulseaudio-utils SDL2-devel)
            python_build_deps=(gcc libffi-devel libopenssl-devel make readline-devel sqlite3-devel xz-devel zlib-devel)
            wxpython_deps=(freeglut-devel gcc-c++ glib2-devel gstreamer-plugins-base libSM-devel libjpeg-turbo libnotify-devel libpng16-devel make libtiff-devel)
            python_with_venv=(python3 python3-devel python3-pip python3-virtualenv)
            ;;
        *)
            log_message "Error: No compatible package manager found."; exit 1
            ;;
    esac

    case $dep_type in
        script_deps) dependencies=("${script_deps[@]}") ;;
        python_build_deps) dependencies=("${python_build_deps[@]}") ;;
        psychopy_deps) dependencies=("${psychopy_deps[@]}") ;;
        wxpython_deps) dependencies=("${wxpython_deps[@]}") ;;
        python_with_venv) dependencies=("${python_with_venv[@]}") ;;
        *) log_message "Error: Invalid dependency type specified."; exit 1 ;;
    esac

    install_packages "${dependencies[@]}"
}

# Function to check if python version is available in package manager
check_python_pkg_manager() {
    local available_version

    case $pkg_manager in
        apt-get)
            available_version=$(apt-cache policy python3 | grep -m 1 "Candidate:" | awk '{print $2}' | cut -d'.' -f1,2)
            ;;
        yum)
            available_version=$(yum info python3 2> /dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
            ;;
        dnf)
            available_version=$(dnf info python3 2> /dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
            ;;
        pacman)
            available_version=$(pacman -Si python 2> /dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
            ;;
        zypper)
            available_version=$(zypper info python3 2> /dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
            ;;
        *)
            log_message "Error: No compatible package manager found."; exit 1
            ;;
    esac

    if [ "$available_version" == "$python_version" ]; then
        return 0
    else
        log_message "Warning: Python $python_version not available in $pkg_manager."
        return 1
    fi
}

# Function to compare version numbers
version_greater_than() {
    if [[ "$1" =~ ^[0-9]+(\.[0-9]+)*$ ]] && [[ "$2" =~ ^[0-9]+(\.[0-9]+)*$ ]]; then
        [ "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1" ]
    else
        return 1
    fi
}

# Function to get the all versions of a package from PyPI
fetch_versions_from_pypi() {
    package="$1"
    curl -s "https://pypi.org/pypi/$package/json" | jq -r '.releases // {} | keys[]' | sort -Vr
}

# Function to get the latest version of a package from PyPI
get_latest_pypi_version() {
    local pkg="$1"
    local var_name="$2"

    local version
    version=$(curl -s "https://pypi.org/pypi/$pkg/json" | jq -r '.info.version')
    if [ -z "$version" ] || [ "$version" = "null" ]; then
        log_message "Error: Unable to fetch the latest version for package ${package_name}. Exiting."
        exit 1
    fi
    declare -n result=$var_name
    result="$version"
}

transform_package_spec() {
    local package_spec="$1"

    if [[ ! $package_spec =~ ^psychopy== ]] || [ "$psychopy_git_tag" != "true" ]; then
        echo "$package_spec"
        return 0
    fi

    local version=${package_spec#psychopy==}
    echo "git+https://github.com/psychopy/psychopy.git@${version}"
}

# Function to check if a specific version of a package exists on PyPI (extra rule for psychopy)
check_pypi_for_version() {
    local package="$1"
    local version="$2"
    local GITHUB_API="https://api.github.com/repos/psychopy/psychopy/git/refs/tags"
    local PYPI_API="https://pypi.org/pypi"

    if curl -s "${PYPI_API}/${package}/${version}/json" | jq -e .info.version > /dev/null; then
        return 0
    fi

    if [ "${package}" = "psychopy" ]; then
        if curl -s -H "Accept: application/vnd.github.v3+json" \
            "${GITHUB_API}/${version}" | jq -e .ref > /dev/null; then
            log_message "Warning: ${package} version ${version} not found on PyPi but as git tag"
            psychopy_git_tag=true
            return 0
        fi
    fi

    log_message "Error: ${package} version ${version} not found on PyPI. Exiting."
    exit 1
}

# Function to check if python is in path and pip and venv are installed
check_python_env() {
    local python_cmd="$1"
    if ! command -v "$python_cmd" > /dev/null 2>&1; then
        log_message "Error: $python_cmd not found. Exiting."
        exit 1
    fi

    if ! "$python_cmd" -m venv --help > /dev/null 2>&1; then
        log_message "Error: $python_cmd found, but venv module is not available. Exiting."
        exit 1
    fi

    if ! "$python_cmd" -m pip --version > /dev/null 2>&1; then
        log_message "Error: $python_cmd found, but pip is not installed. Exiting."
        exit 1
    fi
}

# Function to build Python from source
build_python() {
    local official_base_url latest_patch_version official_url temp_file temp_dir
    log_message "Info: Building Python ${python_version} from source this might take a while ..."
    official_base_url="https://www.python.org/ftp/python/"

    latest_patch_version=$(curl -s "${official_base_url}" | grep -oP "${python_version}\.[0-9]+/" | sort -V | tail -n 1 | sed 's:/$::')

    official_url="${official_base_url}${latest_patch_version}/Python-${latest_patch_version}.tgz"
    temp_file="Python-${latest_patch_version}.tgz"
    temp_dir="Python-${latest_patch_version}_temp"

    if ! log curl -L -o "${temp_file}" "${official_url}"; then
        log_message "Error: Failed to download Python-${latest_patch_version} from python.org"
        exit 1
    fi

    mkdir -p "${temp_dir}" || { log_message "Error: Failed to create temp directory."; exit 1; }

    if ! tar -xf "${temp_file}" -C "${temp_dir}"; then
        log_message "Error: Failed to extract ${temp_file}."
        exit 1
    fi

    cd "${temp_dir}/Python-${latest_patch_version}" || { log_message "Error: Failed to change directory."; exit 1; }
    log ./configure --enable-optimizations --with-ensurepip=install --prefix=/usr/local/psychopy_python
    log make -j "$(nproc)"
    sudo_wrapper make altinstall
    cd "${psychopy_dir}" || { log_message "Error: Failed to return to psychopy directory."; exit 1; }

    sudo_wrapper rm -rf "${temp_dir}" "${temp_file}"
    return 0
}

# Function to download prebuilt Python from GitHub release
python_github_install() {
    local asset_name api_url github_api_header assets_json temp_file temp_dir github_download_url python_version_pattern latest_release_tag

    github_api_header="Accept: application/vnd.github.v3+json"
    latest_release_tag=$(curl -s -H "$github_api_header" "https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest" | jq -r .tag_name)
    api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/tags/v${script_version}"
    assets_json=$(curl -s -H "$github_api_header" "$api_url")

    python_version_pattern="python-${python_version}\.[0-9]+-${processor_structure}-${os_version}\.tar\.gz"
    asset_name=$(echo "$assets_json" | jq -r '.assets // [] | .[].name' | grep -E "$python_version_pattern" | sort -V | tail -n 1)

    # If no matching asset is found AND the script version is NOT the latest, check the latest release
    if [[ -z "$asset_name" && "v${script_version}" != "$latest_release_tag" ]]; then
        log_message "Warning: No matching Python version found in v${script_version}. Checking the latest release ($latest_release_tag)..."
        api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest"
        assets_json=$(curl -s -H "$github_api_header" "$api_url")
        asset_name=$(echo "$assets_json" | jq -r '.assets // [] | .[].name' | grep -E "$python_version_pattern" | sort -V | tail -n 1)
    fi

    if [ -z "$asset_name" ]; then
        log_message "Warning: No matching Python version found in v${script_version} or latest release ($latest_release_tag) for Python ${python_version}."
        return 1
    fi

    github_download_url=$(echo "$assets_json" | jq -r --arg name "$asset_name" '.assets // [] | .[] | select(.name == $name) | .browser_download_url')

    if [ -z "$github_download_url" ]; then
        log_message "Warning: Could not find a download URL for asset $asset_name."
        return 1
    fi

    log_message "Info: Downloading $asset_name from GitHub ..."
    if log curl -L -o "$asset_name" "$github_download_url"; then
        log_message "Info: Successfully downloaded ${asset_name} from GitHub release v${script_version}. Making an altinstall ..."
        temp_dir="${asset_name%.tar.gz}_temp"
        mkdir -p "$temp_dir" || { log_message "Warning: Failed to create temp directory."; return 1; }

        if tar -xf "$asset_name" -C "$temp_dir"; then
            cd "$temp_dir" || { log_message "Warning: Failed to change directory."; return 1; }
            sudo_wrapper make altinstall
            cd "${psychopy_dir}" || { log_message "Warning: Failed to return to psychopy directory."; return 1; }
            sudo_wrapper rm -rf "$temp_dir" "$asset_name"
            return 0
        else
            log_message "Warning: Failed to extract $asset_name."
            sudo_wrapper rm -rf "$temp_dir"
            return 1
        fi
    else
        log_message "Warning: Failed to download from GitHub release."
        return 1
    fi
}

build_wxpython() {
    local tmp_size_gb

    log_message "Info: Installing wxPython build dependencies. This might take a while ..."
    install_dependencies wxpython_deps

    # Check /tmp size and warn if â‰¤2GB (non-blocking)
    tmp_size_gb=$(df -B1G --output=size /tmp 2>/dev/null | tail -n1 | tr -d ' ' || echo 0)
    [ "$tmp_size_gb" -le 2 ] && log_message "Warning: /tmp is only ${tmp_size_gb}GB. wxPython build may fail. Please increase your /tmp size."

    log_message "Info: Building wxPython $wxpython_version from source. This might take a while ..."
    if pip install --no-binary=wxpython --no-cache-dir --force-reinstall "wxpython==$wxpython_version"; then
        log_message "Info: Successfully built wxPython from source."
    else
        log_message "Error: Building wxPython from source failed."
        exit 1
    fi
}

# Function to install wxPython from GitHub release
wxpython_github_install() {
    local api_url assets_json latest_release_tag github_api_header wheel_name renamed_wheel download_url python_version_major_minor

    github_api_header="Accept: application/vnd.github.v3+json"
    latest_release_tag=$(curl -s -H "$github_api_header" "https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest" | jq -r .tag_name)
    api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/tags/v${script_version}"
    assets_json=$(curl -s -H "$github_api_header" "$api_url")

    python_version_major_minor=$(echo "${python_version}" | awk -F. '{printf "%s%s", $1, $2}')
    wheel_name="wxPython-${wxpython_version}-cp${python_version_major_minor}-cp${python_version_major_minor}-${processor_structure}-${os_version}.whl"
    download_url=$(echo "$assets_json" | jq -r --arg name "$wheel_name" '.assets // [] | .[] | select(.name == $name) | .browser_download_url')

    # If no matching wheel is found AND the script version is NOT the latest, check the latest release
    if [[ -z "$download_url" && "v${script_version}" != "$latest_release_tag" ]]; then
        log_message "Info: No matching wxPython wheel found in v${script_version}. Checking the latest release ($latest_release_tag)..."
        api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest"
        assets_json=$(curl -s -H "$github_api_header" "$api_url")
        download_url=$(echo "$assets_json" | jq -r --arg name "$wheel_name" '.assets // [] | .[] | select(.name == $name) | .browser_download_url')
    fi

    # If still not found, exit with an error
    if [ -z "$download_url" ]; then
        log_message "Warning: No matching wxPython wheel found in v${script_version} or latest release ($latest_release_tag) for wxPython ${wxpython_version}."
        return 1
    fi

    log_message "Info: Downloading $wheel_name from GitHub ..."
    if log curl -L -o "$wheel_name" "$download_url"; then
        log_message "Info: Successfully downloaded wxPython wheel from GitHub release. Installing wxPython from $wheel_name..."
        renamed_wheel="${wheel_name%-"${os_version}".whl}.whl"
        mv "$wheel_name" "$renamed_wheel"
        if log pip install "$renamed_wheel"; then
            log_message "Info: Installed wxPython from $renamed_wheel"
            sudo_wrapper mkdir -p /usr/local/psychopy_python/wx_wheels
            sudo_wrapper mv "$renamed_wheel" /usr/local/psychopy_python/wx_wheels/
            return 0
        else
            log_message "Warning: Installing wxPython from $renamed_wheel failed."
            rm "$renamed_wheel"
            return 1
        fi
    else
        log_message "Warning: Downloading $wheel_name failed."
        return 1
    fi
}

# Function to create a desktop shortcut file
create_desktop_shortcut() {
    local desktop_shortcut
    local desktop_dir="${HOME}/.local/share/applications/"
    local psychopy_exec="${psychopy_dir}/bin/psychopy"
    local resources_dir="${psychopy_dir}/Resources"
    local shortcuts=()

    desktop_shortcut="$(xdg-user-dir DESKTOP)"

    if [ -n "$venv_name" ]; then
        shortcuts+=(
            "--no-splash" "$venv_name" "psychopy.png"
            "--builder --no-splash" "Builder $venv_name" "builder.png"
            "--coder --no-splash" "Coder $venv_name" "coder.png"
        )
    else
        shortcuts+=(
            "--no-splash" "PsychoPy (v${psychopy_version}) Python(v${python_version})" "psychopy.png"
            "--builder --no-splash" "PsychoPy Builder (v${psychopy_version}) Python(v${python_version})" "builder.png"
            "--coder --no-splash" "PsychoPy Coder (v${psychopy_version}) Python(v${python_version})" "coder.png"
        )
    fi

    if [ ! -d "$desktop_shortcut" ]; then
        log_message "Warning: Desktop directory $desktop_shortcut does not exist. Skipping desktop shortcut creation."
        return
    fi

    mkdir -p "${resources_dir}"

    for ((i=0; i<${#shortcuts[@]}; i+=3)); do
        local exec_args="${shortcuts[i]}"
        local pretty_name="${shortcuts[i+1]}"
        local icon_file="${shortcuts[i+2]}"
        local icon_url="https://raw.githubusercontent.com/wieluk/psychopy_linux_installer/main/Resources/${icon_file}"
        local desktop_file="${desktop_shortcut}/${pretty_name}.desktop"
        local icon_path="${resources_dir}/${icon_file}"

        if curl --output /dev/null --silent --head --fail "${icon_url}"; then
            log curl -s -o "${icon_path}" "${icon_url}"
        else
            log_message "Warning: Icon file ${icon_url} not found, skipping..."
        fi

        local icon_line=""
        if [ -f "$icon_path" ]; then
            icon_line="Icon=${icon_path}"
        fi

        local desktop_content="[Desktop Entry]
Version=1.0
Name=${pretty_name}
Comment=Run PsychoPy version ${psychopy_version} with ${exec_args}
Exec=${psychopy_exec} ${exec_args}
${icon_line}
Terminal=false
Type=Application
Categories=Education;Science;"

        sh -c "echo '$desktop_content' > '$desktop_file'"
        sudo_wrapper chmod +x "$desktop_file"
        sudo_wrapper chown "$USER" "$desktop_file"
        gio set "$desktop_file" metadata::trusted true
        sudo_wrapper ln -sf "$desktop_file" "${desktop_dir}${pretty_name}.desktop"
    done
    log_message "Info: Desktop shortcuts created."
}

# Function to create add PsychoPy to system path
add_psychopy_to_path() {
    local shell_name
    local bin_dir="${psychopy_dir}/.bin"

    if [ -n "$venv_name" ]; then
        local target_bin="${bin_dir}/${venv_name}"
    else
        local target_bin="${bin_dir}/psychopy_${psychopy_version}_py${python_version}"
    fi

    shell_name=$(basename "$SHELL")
    mkdir -p "$bin_dir"
    ln -sf "${psychopy_dir}/bin/psychopy" "$target_bin"

    local config_file=""
    local path_line=""

    case $shell_name in
        bash)
            config_file="$HOME/.bashrc"
            path_line="export PATH=\"${bin_dir}:\$PATH\""
            ;;
        zsh)
            config_file="$HOME/.zshrc"
            path_line="export PATH=\"${bin_dir}:\$PATH\""
            ;;
        fish)
            config_file="$HOME/.config/fish/config.fish"
            path_line="set -gx PATH \"${bin_dir}\" \$PATH"
            ;;
        csh|tcsh)
            config_file="$HOME/.${shell_name}rc"
            path_line="setenv PATH ${bin_dir}:\$PATH"
            ;;
        *)
            log_message "Warning: Unsupported shell: $shell_name; PsychoPy not added to path"
            ;;
    esac

    if ! grep -Fxq "$path_line" "$config_file"; then
        sh -c "echo '$path_line' >> \"$config_file\""
        log_message "Info: PsychoPy path added to $config_file"
    else
        log_message "Info: PsychoPy path already exists in $config_file"
    fi
}

show_gui() {
    # Optional Select requirements.txt
    zenity --question --title="Use requirements.txt" \
    --text="Do you want to use a requirements.txt file?\n\nIf you don't know what this is, choose 'No' to proceed with manual setup." \
    --ok-label="Yes" --cancel-label="No"

    if [ $? -eq 0 ]; then
        requirements_file=$(zenity --file-selection --title="Select requirements.txt" --file-filter="requirements.txt | *.txt")
        if [ $? -eq 0 ] && [ -n "$requirements_file" ]; then
            use_requirements=true
        else
            exit 1
        fi
    else
        use_requirements=false
    fi

    if [ "$use_requirements" = false ]; then
        # Select PsychoPy version
        psychopy_versions=$(fetch_versions_from_pypi psychopy)
        psychopy_version=$(zenity --list --title="PsychoPy Version" \
            --text="Select the PsychoPy version:" \
            --radiolist --column="Select" --column="Version" \
            TRUE "${default_opts[psychopy_version]}" $(echo "$psychopy_versions" | xargs -I{} printf "FALSE %s " {}) | tr -d '"')
        psychopy_version=$(echo "$psychopy_version" | xargs)
        if [ $? -ne 0 ] || [ -z "$psychopy_version" ]; then
            exit 1
        fi

        # Select Python version
        python_version=$(zenity --list --title="Select Python Version" \
            --text="Choose the Python version for this installation.\n\nPython ${default_opts[python_version]} is recommended for best compatibility." \
            --radiolist --column="Select" --column="Version" \
            TRUE "3.10" FALSE "3.9" FALSE "3.8")
        python_version=$(echo "$python_version" | xargs)
        if [ $? -ne 0 ] || [ -z "$python_version" ]; then
            exit 1
        fi

        # Select wxPython version
        wxpython_versions=$(fetch_versions_from_pypi wxPython)
        wxpython_version=$(zenity --list --title="Select wxPython Version" \
            --text="Choose the wxPython version for this installation.\n\nVersion ${default_opts[wxpython_version]} is recommended for most setups." \
            --radiolist --column="Select" --column="Version" \
            TRUE "${default_opts[wxpython_version]}" $(echo "$wxpython_versions" | grep -v "${default_opts[wxpython_version]}" | xargs -I{} printf "FALSE %s " {}) | tr -d '"')
        wxpython_version=$(echo "$wxpython_version" | xargs)
        if [ $? -ne 0 ] || [ -z "$wxpython_version" ]; then
            exit 1
        fi

        # Additional packages
        additional_packages=$(zenity --entry --title="Additional Packages" \
            --text="Specify additional pip packages to install (comma-separated).\nExample: psychopy-bids,another-package==1.2.3,package3\n\nLeave Empty for no additonal packages" \
            --entry-text="")
        additional_packages=$(echo "$additional_packages" | xargs)
        if [ $? -ne 0 ]; then
            exit 1
        fi
    fi

    # Installation directory
    install_dir=$(zenity --file-selection --directory --title="Select Installation Directory")
    install_dir=$(echo "$install_dir" | xargs)
    if [ $? -ne 0 ] || [ -z "$install_dir" ]; then
        exit 1
    fi

    # Prompt for custom virtual environment name
    venv_name=$(zenity --entry --title="Custom Virtual Environment Name" \
        --text="Enter a custom name for the virtual environment folder.\n\nIf left empty, a versioned folder will be created automatically.\nPress OK without entering a name to use the default versioned format.\n\nThis folder will be created inside:\n$install_dir\n\nNote: Any spaces in the name will be replaced with underscores (_).\n\nExample: my_custom_env" \
        --entry-text="")
    venv_name=$(echo "$venv_name" | xargs)
    if [ $? -ne 0 ]; then
        exit 1
    fi

    # Additional options with tooltips
    options=$(zenity --list --checklist --title="Additional Options" \
        --text="Select additional options:" \
        --column="Select" --column="Option" \
        TRUE "Create desktop shortcuts" \
        TRUE "Add PsychoPy to system PATH" \
        FALSE "Run in non-interactive mode" \
        FALSE "Force overwrite of existing directory" \
        FALSE "Build Python from source" \
        FALSE "Build wxPython from source" \
        FALSE "Enable verbose output")
    if [ $? -ne 0 ]; then
        exit 1
    fi

    if [[ $options == *"Build Python from source"* ]]; then
        build_python=true
    fi

    if [[ $options == *"Build wxPython from source"* ]]; then
        build_wx=true
    fi

    if [[ $options == *"Create desktop shortcuts"* ]]; then
        disable_shortcut=false
    else
        disable_shortcut=true
    fi

    if [[ $options == *"Add PsychoPy to system PATH"* ]]; then
        disable_path=false
    else
        disable_path=true
    fi

    if [[ $options == *"Force overwrite of existing directory"* ]]; then
        force_overwrite=true
    fi

    if [[ $options == *"Enable verbose output"* ]]; then
        verbose=true
    fi

    if [[ $options == *"Run in non-interactive mode"* ]]; then
        non_interactive=true
        sudo_mode=auto
    else
        non_interactive=false
    fi

    if [[ $non_interactive == false ]]; then
        sudo_mode=$(zenity --list --title="Sudo Mode" \
            --text="Select the desired sudo mode:\n\
                ask: confirm each sudo usage.\n\
                auto: auto-confirm sudo if required.\n\
                error: exit if sudo is needed.\n\
                continue: skip sudo commands, assuming prerequisites are met.\n\
                force: use sudo for everything." \
            --radiolist --column="Select" --column="Mode" \
            TRUE "ask" FALSE "auto" FALSE "error" FALSE "continue" FALSE "force")
        if [ $? -ne 0 ] || [ -z "$sudo_mode" ]; then
            exit 1
        fi
    fi
}

process_arguments() {
    sudo_mode_set=false

    for arg in "$@"; do
        case $arg in
            --psychopy-version=*)
                psychopy_version="${arg#*=}"
                ;;
            --python-version=*)
                python_version="${arg#*=}"
                if [[ ! $python_version =~ ^3\.(8|9|10)$ ]]; then
                    log_message "Error: Invalid Python version specified. Only versions 3.8, 3.9, or 3.10 are allowed."
                    exit 1
                fi
                ;;
            --wxpython-version=*)
                wxpython_version="${arg#*=}"
                ;;
            --additional-packages=*)
                additional_packages="${arg#*=}"
                ;;
            --requirements-file=*)
                requirements_file="${arg#*=}"
                ;;
            --build=*)
                build_arg="${arg#*=}"
                case $build_arg in
                    python)
                        build_python=true
                        ;;
                    wxpython)
                        build_wx=true
                        ;;
                    both)
                        build_python=true
                        build_wx=true
                        ;;
                    *)
                        log_message "Error: Invalid option for --build: $build_arg"
                        show_help
                        exit 1
                        ;;
                esac
                ;;
            --install-dir=*)
                install_dir="${arg#*=}"
                ;;
            --venv-name=*)
                venv_name="${arg#*=}"
                ;;
            --sudo-mode=*)
                sudo_mode="${arg#*=}"
                if [[ "$sudo_mode" != "ask" && "$sudo_mode" != "continue" && "$sudo_mode" != "auto" && "$sudo_mode" != "error"  && "$sudo_mode" != "force" ]]; then
                    log_message "Error: Invalid value for --sudo_mode. Valid options are 'ask', 'continue', 'auto', 'error' or 'force'."
                    exit 1
                fi
                sudo_mode_set=true
                ;;
            --disable-shortcut)
                disable_shortcut=true
                ;;
            --disable-path)
                disable_path=true
                ;;
            --non-interactive)
                non_interactive=true
                if [ "$sudo_mode_set" = false ]; then
                    sudo_mode=auto
                fi
                ;;
            -f|--force)
                force_overwrite=true
                ;;
            -v|--verbose)
                verbose=true
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_message "Error: Unknown option: $arg"
                show_help
                exit 1
                ;;
        esac
    done
}

main() {
    pkg_manager_permission=false
    psychopy_git_tag=false
    temporary_sudo_setup_done=false
    use_gui=false

    for arg in "$@"; do
        if [[ "$arg" == "--gui" ]]; then
            use_gui=true
            break
        fi
    done

    if $use_gui; then
        if ! command -v zenity &> /dev/null; then
            log_message "Error: zenity is not installed or not available in PATH. Cannot use GUI mode. Exiting."
            exit 1
        else
            show_gui
        fi
    else
        process_arguments "$@"
    fi

    if [ -n "$requirements_file" ]; then
        log_message "Info: Parsing requirements file: $requirements_file..."
        parse_requirements_file "$requirements_file"
    fi

    # Ensure defaults for unset variables
    for key in "${!default_opts[@]}"; do
        if [ -z "${!key+x}" ]; then
            eval "$key='${default_opts[$key]}'"
        fi
    done

    venv_name=${venv_name//[[:space:]]/_}


    # Detect OS version and architecture
    os_version=$(detect_os_version | tr '[:upper:]' '[:lower:]')
    processor_structure=$(uname -s | tr '[:upper:]' '[:lower:]')_$(uname -m)
    script_version=$(grep -m 1 'Version:' "$0" | sed 's/[^0-9.]//g')
    log_message "Info: Initiating PsychoPy(${psychopy_version}) installation using psychopy_linux_installer v${script_version} on ${os_version} (${processor_structure})."

    # Detect package manager
    pkg_manager=$(detect_package_manager)

    # Update package manager
    log_message "Info: Updating ${pkg_manager} package manager."
    update_package_manager "$pkg_manager"

    # Install basic dependencies
    log_message "Info: Installing git, curl, and jq."
    install_dependencies script_deps

    # Check for script update
    if [ "$non_interactive" = false ]; then
        check_for_updates
    fi

    # Determine PsychoPy version to install
    if [ "$psychopy_version" == "latest" ]; then
        get_latest_pypi_version "psychopy" psychopy_version
    elif [ "$psychopy_version" != "git" ]; then
        check_pypi_for_version psychopy "${psychopy_version}"
    fi

    # Install PsychoPy dependencies
    log_message "Info: Installing PsychoPy dependencies. This might take a while ..."
    install_dependencies psychopy_deps

    # Set up PsychoPy installation directory
    if [ -n "$venv_name" ]; then
        psychopy_dir="${install_dir}/${venv_name}"
    else
        psychopy_dir="${install_dir}/psychopy_${psychopy_version}_py${python_version}"
    fi

    if [ -d "${psychopy_dir}" ]; then
        if [ "$force_overwrite" = true ]; then
            log_message "Info: Directory ${psychopy_dir} already exists. Overwriting ..."
            sudo_wrapper rm -rf "${psychopy_dir}"
            sudo_wrapper mkdir -p "${psychopy_dir}"
        else
            log_message "Error: Directory ${psychopy_dir} already exists. Use the --force flag to overwrite. Exiting."
            exit 1
        fi
    else
        log_message "Info: Creating PsychoPy directory at ${psychopy_dir} ..."
        sudo_wrapper mkdir -p "${psychopy_dir}"
    fi

    [ -w "${psychopy_dir}" ] || sudo_wrapper chown "$USER" "${psychopy_dir}"

    if ! [ -w "${psychopy_dir}" ] || ! cd "${psychopy_dir}"; then
        log_message "Error: Failed to access or change directory to ${psychopy_dir}. Exiting."
        exit 1
    fi

    # Install python and create venv
    if [ "$build_python" = true ] || ! check_python_pkg_manager; then
        if [ "$build_python" = true ]; then
            log_message "Info: Installing python build dependencies ..."
            install_dependencies python_build_deps
            build_python
        else
            if [ -x "/usr/local/psychopy_python/bin/python${python_version}" ]; then
                log_message "Info: Python version ${python_version} is already installed in /usr/local/psychopy_python. Skipping installation."
            else
                log_message "Info: Installing python build dependencies ..."
                install_dependencies python_build_deps
                if python_github_install; then
                    :
                else
                    build_python
                fi
            fi
        fi

        if [ ! -x "/usr/local/psychopy_python/bin/python${python_version}" ]; then
            log_message "Error: python${python_version} not found in /usr/local/psychopy_python. Something went wrong while installing/building. Try --build=python and --verbose as arguments."
            exit 1
        fi
        export PATH=/usr/local/psychopy_python/bin:$PATH
        /usr/local/psychopy_python/bin/python"${python_version}" -m venv "${psychopy_dir}"
    else
        log_message "Info: Python${python_version} can be installed via package manager. Installing ..."
        install_dependencies python_with_venv
        check_python_env "python${python_version}"
        python"${python_version}" -m venv "${psychopy_dir}"
    fi

    # Activate venv
    log_message "Info: Succesfully created Python${python_version} venv in ${psychopy_dir} ... Activating."
    log source "${psychopy_dir}/bin/activate"
    check_python_env "python"

    # Upgrade pip and install required Python packages
    log_message "Info: Upgrading pip, distro, sip, six, psychtoolbox, attrdict, setuptools, wheel ..."
    log pip install -U pip distro sip six psychtoolbox setuptools wheel
    if [[ "${python_version}" == "3.8" || "${python_version}" == "3.9" ]]; then
        log pip install -U attrdict
    elif [[ "${python_version}" == "3.10" ]]; then
        log pip install -U attrdict3
    fi

    # Determine wxPython version and install it
    log_message "Info: Installing wxpython ..."
    if [ "$wxpython_version" = "latest" ]; then
        get_latest_pypi_version "wxPython" wxpython_version
    elif [ "$wxpython_version" != "git" ]; then
        check_pypi_for_version wxpython "${wxpython_version}"
    fi

    if [ "$wxpython_version" = "git" ]; then
        log_message "Info: Installing wxPython build dependencies. This might take a while ..."
        install_dependencies wxpython_deps
        log_message "Info: Building wxPython from git. This might take a while ..."
        log pip install git+https://github.com/wxWidgets/Phoenix

    elif [ "$build_wx" = true ]; then
        build_wxpython

    else
        log pip install --only-binary=:all: --find-links /usr/local/psychopy_python/wx_wheels/ "wxpython==$wxpython_version" || \
        log pip install --only-binary=:all: --find-links https://extras.wxpython.org/wxPython4/extras/linux/gtk3/ "wxPython==$wxpython_version" || \
        wxpython_github_install || \
        build_wxpython
    fi

    if ! pip show wxPython &> /dev/null; then
        log_message "Error: wxPython is not installed. Something went wrong during the installation. Use --verbose and maybe --build=wxpython flags."
        exit 1
    fi

    if [ -n "$requirements_file" ]; then
        log_message "Info: Installing packages from requirements file..."
        transformed_packages=$(echo "$backup_additional_packages" | tr ',' '\n' | while read -r pkg; do
            transform_package_spec "$pkg"
        done)

        if log pip install -r <(echo "$transformed_packages"); then
            log_message "Info: Packages from $requirements_file installed successfully."
        else
            log_message "Warning: Failed to install packages from $requirements_file. Installing packages one by one ..."
            IFS=',' read -ra PACKAGES <<< "$backup_additional_packages"
            for package in "${PACKAGES[@]}"; do
                log_message "Info: Installing $package..."
                transformed_pkg=$(transform_package_spec "$package")
                if log pip install "$transformed_pkg"; then
                    pkg_name="${package%%=*}"
                    installed_version=$(pip show "$pkg_name" | grep Version | cut -d' ' -f2)
                    log_message "Info: $pkg_name version $installed_version installed successfully."
                else
                    log_message "Warning: Failed to install $package. Skipping."
                fi
            done
        fi
    else
        # Install PsychoPy
        log_message "Info: Installing PsychoPy version ${psychopy_version}"
        if [ "$psychopy_version" == "git" ]; then
            log pip install git+https://github.com/psychopy/psychopy.git@dev
        elif [ "$psychopy_git_tag" = "true" ]; then
            log pip install "git+https://github.com/psychopy/psychopy.git@${psychopy_version}"
        else
            log pip install psychopy=="${psychopy_version}"
        fi

        if ! pip show psychopy &> /dev/null; then
            log_message "Error: PsychoPy is not installed successfully. Something went wrong during the installation. Use the --verbose flag."
            exit 1
        fi

        # Install additional packages if specified
        if [ -n "$additional_packages" ]; then
            log_message "Info: Installing additional packages..."
            IFS=',' read -ra PACKAGES <<< "$additional_packages"
            for package in "${PACKAGES[@]}"; do
                log_message "Info: Installing $package..."
                if log pip install "$package"; then
                    installed_version=$(pip show "${package%%=*}" | grep Version | cut -d' ' -f2)
                    log_message "Info: ${package%%=*} version $installed_version installed successfully."
                else
                    log_message "Warning: Failed to install $package. Skipping."
                fi
            done
        fi
    fi

    # Install numpy<2 if PsychoPy version is less than 2024.2.0
    if version_greater_than "2024.2.0" "$psychopy_version"; then
        log_message "Warning: PsychoPy version < 2024.2.0, installing numpy<2"
        log pip install "numpy<2"
    fi

    # Deactivate virtual environment
    deactivate

    # Add user to the 'psychopy' group and set security limits
    log_message "Info: Adding ${USER} to psychopy group and setting security limits in /etc/security/limits.d/99-psychopylimits.conf."
    sudo_wrapper groupadd --force psychopy
    sudo_wrapper usermod -a -G psychopy "$USER"
    sudo_wrapper sh -c 'echo "@psychopy - nice -20\n@psychopy - rtprio 50\n@psychopy - memlock unlimited" > /etc/security/limits.d/99-psychopylimits.conf'

    # Create desktop shortcut
    if [ "$disable_shortcut" = false ]; then
        create_desktop_shortcut
    fi

    # Add PsychoPy to PATH
    if [ "$disable_path" = false ]; then
        add_psychopy_to_path
        echo
        echo "To start PsychoPy from the system path, use:"
        if [ -n "$venv_name" ]; then
            echo "${venv_name}"
        else
            echo "psychopy_${psychopy_version}_py${python_version}"
        fi
    fi

    echo
    echo "To start PsychoPy using the absolute path, use:"
    echo "${psychopy_dir}/bin/psychopy"
    echo
    echo "Please reboot to apply security limits and refresh the system path."
    echo
    log_message "PsychoPy installation complete!"
}

main "$@"
