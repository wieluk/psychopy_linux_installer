#!/bin/bash
# ==============================================================================
#  Title:         psychopy_linux_installer
#  Description:   This script installs PsychoPy with specified versions of
#                 Python, wxPython, and optional packages.
#  Author:        Lukas Wiertz
#  Date:          2025-03-27
#  Version:       1.5.4
#  License:       GNU General Public License v3.0
# ==============================================================================

# Define default values
declare -A DEFAULT_OPTS=(
    [PSYCHOPY_VERSION]="latest"
    [PYTHON_VERSION]="3.10"
    [WXPYTHON_VERSION]="4.2.2"
    [BUILD_PYTHON]=false
    [BUILD_WX]=false
    [INSTALL_DIR]="${HOME}"
    [VENV_NAME]=""
    [ADDITIONAL_PACKAGES]=""
    [SUDO_MODE]="ask"
    [DISABLE_SHORTCUT]=false
    [DISABLE_PATH]=false
    [NON_INTERACTIVE]=false
    [FORCE_OVERWRITE]=false
    [VERBOSE]=false
    [REMOVE_PSYCHOPY_SETTINGS]=false
)

# Displays usage information and available options.
show_help() {
    local help_text
    help_text=$(
        printf "%s\n" \
            "Usage: ./psychopy_linux_installer [options]" \
            "Options:" \
            "  --psychopy-version=VERSION                    Specify PsychoPy version (default: ${DEFAULT_OPTS[PSYCHOPY_VERSION]})." \
            "  --python-version=3.8|3.9|3.10                 Specify Python version (default: ${DEFAULT_OPTS[PYTHON_VERSION]})." \
            "  --wxpython-version=VERSION                    Specify wxPython version (default: ${DEFAULT_OPTS[WXPYTHON_VERSION]})." \
            "  --requirements-file=FILE                      Specify a requirements.txt file to define dependencies." \
            "  --build=[python|wxpython|both]                Build Python and/or wxPython from source instead of downloading. Not recommended, only use if installation doesn't work as expected." \
            "  --install-dir=DIR                             Specify installation directory (default: \"${DEFAULT_OPTS[INSTALL_DIR]}\")." \
            "  --venv-name=NAME                              Specify a custom name for the virtual environment folder. If omitted, a versioned subdirectory will be used by default." \
            "  --additional-packages=PACKAGES                Specify additional pip packages to install. Format: package1==version,package2." \
            "  --sudo-mode=[ask|auto|error|continue|force]   Control sudo usage. ask: confirm, auto: auto-confirm, error: exit if sudo needed, continue: continue without sudo, force: use sudo directly (default: ${DEFAULT_OPTS[SUDO_MODE]})." \
            "  --disable-shortcut                            Disable desktop shortcut creation." \
            "  --non-interactive                             Run the installer without user interaction. Sets sudo-mode to auto if not set." \
            "  --disable-path                                Disable adding PsychoPy to system path." \
            "  --gui                                         Launches the installer in GUI mode, allowing you to set arguments interactively. Any arguments provided via the command line will be ignored while in GUI mode." \
            "  --remove-psychopy-settings                    Remove existing PsychoPy user settings (${HOME}/.psychopy3). Retaining this folder can sometimes result in conflicts with plugins or non-default pip-installed packages." \
            "  -f, --force-overwrite                         Force overwrite of existing installation directory." \
            "  -v, --verbose                                 Enable verbose output for the terminal (logfile output is always verbose)." \
            "  -h, --help                                    Show this help message."
    )
    echo "${help_text}"
}

# Log message function that writes colored output to terminal and plain text to the log file. It also handles exits on error.
log_message() {
    local reset="\033[0m" green="\033[32m" yellow="\033[33m" red="\033[31m" cyan="\033[36m"
    local timestamp formatted_message plain_message
    local nolog_option="${2}"
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Disable colors if output is not a terminal.
    if [[ ! -t 1 ]]; then
        reset=""
        green=""
        yellow=""
        red=""
        cyan=""
    fi

    case "${1}" in
    INFO:*)
        formatted_message=$(printf "%s - %b%s%b" "${timestamp}" "${green}" "${1}" "${reset}")
        ;;
    WARNING:*)
        formatted_message=$(printf "%s - %b%s%b" "${timestamp}" "${yellow}" "${1}" "${reset}")
        ;;
    ERROR:*)
        formatted_message=$(printf "%s - %b%s%b" "${timestamp}" "${red}" "${1}" "${reset}")
        ;;
    NOTE:*)
        formatted_message=$(printf "%s - %b%s%b" "${timestamp}" "${cyan}" "${1}" "${reset}")
        ;;
    *)
        formatted_message=$(printf "%s - %s" "${timestamp}" "${1}")
        ;;
    esac

    plain_message="${timestamp} - ${1}"
    echo "${plain_message}" >>"${LOG_FILE}"
    printf "%s\n" "${formatted_message}"

    if [[ "${1}" == ERROR:* ]]; then
        if [[ "${nolog_option}" != "nolog" ]]; then
            printf "%bPlease check the log file at %s for more details.%b\n" "${red}" "${LOG_FILE}" "${reset}"
        fi
        printf "%bExiting.%b\n" "${red}" "${reset}"
        exit 1
    fi
}

# Wrapper to control command output based on verbosity.
log() {
    if [ "${VERBOSE}" = true ]; then
        "${@}" 2>&1 | tee -a "${LOG_FILE}"
        return "${PIPESTATUS[0]}"
    else
        "${@}" >>"${LOG_FILE}" 2>&1
        return ${?}
    fi
}

# Parses the command-line arguments and sets appropriate variables.
process_arguments() {
    local sudo_mode_set build_arg
    sudo_mode_set=false

    for arg in "${@}"; do
        case ${arg} in
        --psychopy-version=*)
            PSYCHOPY_VERSION="${arg#*=}"
            ;;
        --python-version=*)
            PYTHON_VERSION="${arg#*=}"
            if [[ ! ${PYTHON_VERSION} =~ ^3\.(8|9|10)$ ]]; then
                log_message "ERROR: Unsupported Python version '${PYTHON_VERSION}'. Supported versions: '3.8', '3.9', or '3.10'." nolog
            fi
            ;;
        --wxpython-version=*)
            WXPYTHON_VERSION="${arg#*=}"
            ;;
        --additional-packages=*)
            ADDITIONAL_PACKAGES="${arg#*=}"
            ;;
        --requirements-file=*)
            REQUIREMENTS_FILE="${arg#*=}"
            ;;
        --build=*)
            build_arg="${arg#*=}"
            case ${build_arg} in
            python)
                BUILD_PYTHON=true
                ;;
            wxpython)
                BUILD_WX=true
                ;;
            both)
                BUILD_PYTHON=true
                BUILD_WX=true
                ;;
            *)
                log_message "ERROR: Invalid --build option: '${build_arg}'." nolog
                show_help
                ;;
            esac
            ;;
        --install-dir=*)
            INSTALL_DIR="${arg#*=}"
            ;;
        --venv-name=*)
            VENV_NAME="${arg#*=}"
            ;;
        --sudo-mode=*)
            SUDO_MODE="${arg#*=}"
            if [[ "${SUDO_MODE}" != "ask" && "${SUDO_MODE}" != "continue" && "${SUDO_MODE}" != "auto" && "${SUDO_MODE}" != "error" && "${SUDO_MODE}" != "force" ]]; then
                log_message "ERROR: Invalid value for --sudo-mode. Valid options are 'ask', 'continue', 'auto', 'error' or 'force'." nolog
            fi
            sudo_mode_set=true
            ;;
        --disable-shortcut)
            DISABLE_SHORTCUT=true
            ;;
        --disable-path)
            DISABLE_PATH=true
            ;;
        --non-interactive)
            NON_INTERACTIVE=true
            if [ "${sudo_mode_set}" = false ]; then
                SUDO_MODE=auto
            fi
            ;;
        --remove-psychopy-settings)
            REMOVE_PSYCHOPY_SETTINGS=true
            ;;
        -f | --force-overwrite)
            FORCE_OVERWRITE=true
            ;;
        -v | --verbose)
            VERBOSE=true
            ;;
        -h | --help)
            show_help
            exit 0
            ;;
        *)
            show_help
            log_message "ERROR: Unknown option: '${arg}'." nolog
            ;;
        esac
    done
}

# Launches a Zenity-based GUI to collect user input interactively.
show_gui() {
    local wxpython_versions psychopy_versions use_requirements options

    # Installation directory
    if INSTALL_DIR=$(zenity --file-selection --directory --title="Select Installation Directory") && [ -n "${INSTALL_DIR}" ]; then
        INSTALL_DIR=$(echo "${INSTALL_DIR}" | xargs)
        :
    else
        exit 0
    fi

    # Prompt for custom virtual environment name
    if VENV_NAME=$(zenity --entry --title="Custom Virtual Environment Name (optional)" --width=800 --height=500 \
        --text="Enter a custom name for the virtual environment folder.\n\nIf left blank, the default versioned name will be used: PsychoPy-{PSYCHOPY_VERSION}-Python{PYTHON_VERSION}.\n\nThis folder will be created inside:\n${INSTALL_DIR}\n\nNote: Spaces in the name will be replaced with underscores.\n\n" \
        --entry-text=""); then
        VENV_NAME=$(echo "${VENV_NAME}" | xargs)
        :
    else
        exit 0
    fi

    # Optional: Select requirements.txt
    if zenity --question --title="Use requirements.txt (optional)" \
        --text="Do you want to use a requirements.txt file?\n\nIf you don't know what this is, choose 'No' to proceed with manual setup." \
        --ok-label="Yes" --cancel-label="No"; then

        if REQUIREMENTS_FILE=$(zenity --file-selection --title="Select requirements.txt" --file-filter="requirements.txt | *.txt") && [ -n "${REQUIREMENTS_FILE}" ]; then
            use_requirements=true
        else
            exit 0
        fi
    else
        use_requirements=false
    fi

    if [ "${use_requirements}" = false ]; then
        # Select PsychoPy version
        psychopy_versions="$(fetch_versions_from_pypi psychopy) + git"
        IFS=' ' read -r -a psychopy_false_opts <<<"$(echo "${psychopy_versions}" | xargs -I{} printf "FALSE %s " {})"
        if PSYCHOPY_VERSION=$(zenity --list --title="PsychoPy Version" --width=800 --height=500 \
            --text="Select the PsychoPy version:" \
            --radiolist --column="Select" --column="Version" \
            TRUE "${DEFAULT_OPTS[PSYCHOPY_VERSION]}" "${psychopy_false_opts[@]}" | tr -d '"') && [ -n "${PSYCHOPY_VERSION}" ]; then
            PSYCHOPY_VERSION=$(echo "${PSYCHOPY_VERSION}" | xargs)
            :
        else
            exit 0
        fi

        # Select Python version
        if PYTHON_VERSION=$(zenity --list --title="Select Python Version" --width=800 --height=500 \
            --text="Choose the Python version for this installation.\n\nPython${DEFAULT_OPTS[PYTHON_VERSION]} is recommended for best compatibility." \
            --radiolist --column="Select" --column="Version" \
            TRUE "3.10" FALSE "3.9" FALSE "3.8") && [ -n "${PYTHON_VERSION}" ]; then
            PYTHON_VERSION=$(echo "${PYTHON_VERSION}" | xargs)
            :
        else
            exit 0
        fi

        # Select wxPython version
        wxpython_versions=$(fetch_versions_from_pypi wxPython)
        IFS=' ' read -r -a wxpython_false_opts <<<"$(echo "${wxpython_versions}" | grep -v "${DEFAULT_OPTS[WXPYTHON_VERSION]}" | xargs -I{} printf "FALSE %s " {})"
        if WXPYTHON_VERSION=$(zenity --list --title="Select wxPython Version" --width=800 --height=500 \
            --text="Choose the wxPython version for this installation.\n\nVersion ${DEFAULT_OPTS[WXPYTHON_VERSION]} is recommended for most setups." \
            --radiolist --column="Select" --column="Version" \
            TRUE "${DEFAULT_OPTS[WXPYTHON_VERSION]}" "${wxpython_false_opts[@]}" | tr -d '"') && [ -n "${WXPYTHON_VERSION}" ]; then
            WXPYTHON_VERSION=$(echo "${WXPYTHON_VERSION}" | xargs)
            :
        else
            exit 0
        fi

        # Additional packages
        if ADDITIONAL_PACKAGES=$(zenity --entry --title="Additional Packages (optional)" --width=800 --height=500 \
            --text="Specify additional pip packages to install (comma-separated).\n\nExample: psychopy-bids,another-package==1.2.3,package3\n\nLeave empty for no additional packages\n\n" \
            --entry-text=""); then
            ADDITIONAL_PACKAGES=$(echo "${ADDITIONAL_PACKAGES}" | xargs)
            :
        else
            exit 0
        fi
    fi

    # Additional options with tooltips
    if options=$(zenity --list --checklist --title="Additional Options" --width=800 --height=500 \
        --text="Select additional options:" \
        --column="Select" --column="Option" \
        TRUE "Add PsychoPy to system PATH" \
        TRUE "Create desktop shortcuts" \
        FALSE "Run in non-interactive mode" \
        FALSE "Force overwrite of existing directory" \
        FALSE "Remove PsychoPy user settings (${HOME}/.psychopy3)" \
        FALSE "Build Python from source" \
        FALSE "Build wxPython from source" \
        FALSE "Enable verbose output"); then
        :
    else
        exit 0
    fi

    if [[ ${options} == *"Add PsychoPy to system PATH"* ]]; then
        DISABLE_PATH=false
    else
        DISABLE_PATH=true
    fi

    if [[ ${options} == *"Create desktop shortcuts"* ]]; then
        DISABLE_SHORTCUT=false
    else
        DISABLE_SHORTCUT=true
    fi

    if [[ ${options} == *"Force overwrite of existing directory"* ]]; then
        FORCE_OVERWRITE=true
    fi

    if [[ ${options} == *"Remove PsychoPy user settings (${HOME}/.psychopy3)"* ]]; then
        REMOVE_PSYCHOPY_SETTINGS=true
    fi

    if [[ ${options} == *"Build Python from source"* ]]; then
        BUILD_PYTHON=true
    fi

    if [[ ${options} == *"Build wxPython from source"* ]]; then
        BUILD_WX=true
    fi

    if [[ ${options} == *"Enable verbose output"* ]]; then
        VERBOSE=true
    fi

    if [[ ${options} == *"Run in non-interactive mode"* ]]; then
        NON_INTERACTIVE=true
        SUDO_MODE=auto
    else
        NON_INTERACTIVE=false
    fi

    if [[ ${NON_INTERACTIVE} == false ]]; then
        if SUDO_MODE=$(zenity --list --title="Sudo Mode" --width=800 --height=500 \
            --text="Select the desired sudo mode:\n\n \
                    ask: Prompt each time sudo is needed.\n \
                    auto: Automatically use sudo when required.\n \
                    error: Exit immediately if a command requires sudo.\n \
                    continue: Attempt to run commands without sudo. If they fail due to missing permissions, proceed without stopping.\n \
                    force: Always use sudo for commands that typically require it, without checking necessity.\n\n" \
            --radiolist --column="Select" --column="Mode" \
            TRUE "ask" FALSE "auto" FALSE "error" FALSE "continue" FALSE "force") && [ -n "${SUDO_MODE}" ]; then
            :
        else
            exit 0
        fi
    fi
}

# Reconstructs a command string to re-run the installer with the current settings.
create_rerun_command() {
    local cmd lowercase_key curr def
    cmd=$(readlink -f "${0}")
    for key in "${!DEFAULT_OPTS[@]}"; do
        [[ "${key}" == "BUILD_PYTHON" || "${key}" == "BUILD_WX" ]] && continue
        curr="${!key}"
        def="${DEFAULT_OPTS[${key}]}"
        lowercase_key=$(echo "${key}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
        if [[ "${curr}" != "${def}" ]]; then
            if [[ "${curr}" == "true" && "${def}" == "false" ]]; then
                cmd+=" --${lowercase_key}"
            elif [[ -n "${curr}" ]]; then
                cmd+=" --${lowercase_key}=${curr}"
            fi
        fi
    done
    if [[ "${BUILD_PYTHON}" == true && "${BUILD_WX}" == true ]]; then
        cmd+=" --build=both"
    elif [[ "${BUILD_PYTHON}" == true ]]; then
        cmd+=" --build=python"
    elif [[ "${BUILD_WX}" == true ]]; then
        cmd+=" --build=wxpython"
    fi
    [ -n "${REQUIREMENTS_FILE}" ] && cmd+=" --requirements-file=${REQUIREMENTS_FILE}"
    echo "${cmd}"
}

# Reads and parses a requirements file, adjusting dependency versions as needed.
parse_requirements_file() {
    local file current_version operator package_name package_version pkg_lower version original_spec new_spec req_python_version req_wxpython_version req_psychopy_version
    local -A package_versions
    local -A package_operators
    file="${1}"

    if [ ! -f "${file}" ] || [ ! -s "${file}" ] || [ ! -r "${file}" ]; then
        log_message "ERROR: Requirements file '${file}' is missing, empty, or inaccessible." nolog
    fi

    while IFS= read -r line; do
        if [[ "${line}" =~ ^# ]] || [[ -z "${line}" ]]; then
            continue
        fi

        if [[ "${line}" =~ ^([A-Za-z0-9._-]+)[[:space:]]*(>=|<=|==|~=|!=|>|<)[[:space:]]*([0-9][A-Za-z0-9._-]*) ]]; then
            package_name="${BASH_REMATCH[1],,}"
            operator="${BASH_REMATCH[2]}"
            package_version="${BASH_REMATCH[3]}"

            if [[ -n "${package_versions[${package_name}]}" ]]; then
                current_version="${package_versions[${package_name}]}"
                if [[ "${operator}" == "==" || "${package_operators[${package_name}]}" != "==" ]]; then
                    package_versions["${package_name}"]="${package_version}"
                    package_operators["${package_name}"]="${operator}"
                fi
            else
                package_versions["${package_name}"]="${package_version}"
                package_operators["${package_name}"]="${operator}"
            fi
        fi
    done <"${file}"

    REQUIREMENTSFILE_PACKAGES=$(for pkg in "${!package_versions[@]}"; do
        if [[ "${pkg}" != "wxpython" && "${pkg}" != "psychopy" && "${pkg}" != "winrt" && "${pkg}" != "pywin32" && "${pkg}" != "pypiwin32" && "${pkg}" != "pywinhook" ]]; then
            echo "${pkg}${package_operators[${pkg}]}${package_versions[${pkg}]}"
        else
            if [[ "${pkg}" != "wxpython" && "${pkg}" != "psychopy" ]]; then
                log_message "WARNING: The Python package '${pkg}' (from requirements.txt) is not available on Linux; skipping." >&2
            fi
        fi
    done | tr '\n' ',' | sed 's/,$//')

    # Extract versions from requirements file
    req_python_version=$(grep -i -E '^# Python version:' "${file}" | cut -d':' -f2 | xargs | cut -d'.' -f1,2 | tr -d '[:space:]' || true)
    req_wxpython_version="${package_versions["wxpython"]:-}"
    req_psychopy_version="${package_versions["psychopy"]:-}"

    # Set or warn for Python version, wxPython version, and PsychoPy version
    if [ -n "${PYTHON_VERSION}" ] && [ -n "${req_python_version}" ] && [ "${PYTHON_VERSION}" != "${req_python_version}" ]; then
        log_message "WARNING: Python version already set to '${PYTHON_VERSION}', but requirements file specifies '${req_python_version}'. Using '${PYTHON_VERSION}'."
    elif [ -z "${PYTHON_VERSION}" ] && [ -n "${req_python_version}" ]; then
        PYTHON_VERSION="${req_python_version}"
    fi

    if [ -n "${WXPYTHON_VERSION}" ] && [ -n "${req_wxpython_version}" ] && [ "${WXPYTHON_VERSION}" != "${req_wxpython_version}" ]; then
        log_message "WARNING: wxPython version already set to '${WXPYTHON_VERSION}', but requirements file specifies '${req_wxpython_version}'. Using '${WXPYTHON_VERSION}'."
    elif [ -z "${WXPYTHON_VERSION}" ] && [ -n "${req_wxpython_version}" ]; then
        WXPYTHON_VERSION="${req_wxpython_version}"
    fi

    if [ -n "${PSYCHOPY_VERSION}" ] && [ -n "${req_psychopy_version}" ] && [ "${PSYCHOPY_VERSION}" != "${req_psychopy_version}" ]; then
        log_message "WARNING: PsychoPy version already set to '${PSYCHOPY_VERSION}', but requirements file specifies '${req_psychopy_version}'. Using '${PSYCHOPY_VERSION}'."
    elif [ -z "${PSYCHOPY_VERSION}" ] && [ -n "${req_psychopy_version}" ]; then
        PSYCHOPY_VERSION="${req_psychopy_version}"
    fi

    [[ -z "${PYTHON_VERSION}" ]] && log_message "WARNING: Python version not specified in the requirements file; using default: '${DEFAULT_OPTS[PYTHON_VERSION]}'."
    [[ -z "${WXPYTHON_VERSION}" ]] && log_message "WARNING: wxPython version not specified in the requirements file; using default: '${DEFAULT_OPTS[WXPYTHON_VERSION]}'."

    if [ -z "${PSYCHOPY_VERSION}" ]; then
        log_message "ERROR: psychopy version not specified in requirements.txt." nolog
    else
        REQUIREMENTSFILE_PACKAGES="${REQUIREMENTSFILE_PACKAGES:+${REQUIREMENTSFILE_PACKAGES},}psychopy==${PSYCHOPY_VERSION}"
    fi

    # Adjust Linux dependencies
    for pkg in pyglet python-vlc; do
        pkg_lower="${pkg,,}"
        if [[ -n "${package_versions[${pkg_lower}]}" ]]; then
            version="${package_versions[${pkg_lower}]}"
            original_spec="${pkg_lower}${package_operators[${pkg_lower}]}${version}"
            new_spec="${pkg_lower}>=${version}"
            if [[ "${REQUIREMENTSFILE_PACKAGES}" == *"${original_spec}"* ]]; then
                REQUIREMENTSFILE_PACKAGES=${REQUIREMENTSFILE_PACKAGES//"${original_spec}"/"${new_spec}"}
                log_message "WARNING: '${pkg}' from the requirements file was installed with a flexible version specification. '${original_spec}' may be platform-specific and was adjusted to '${new_spec}' for Linux compatibility. You may manually install the exact version in the PsychoPy venv." >&2
            fi
        fi
    done
}

# Manages sudo usage and command retries when permissions are insufficient.
sudo_wrapper() {
    local error_output exit_code
    local command=("${@}")
    local is_pkg_manager_command=false

    needs_sudo() {
        local exit_code="${1}"
        local error_output="${2}"

        case ${exit_code} in
        0) return 1 ;;
        1 | 2 | 5 | 10 | 13 | 77 | 100 | 126 | 127) return 0 ;;
        *)
            log_message "WARNING: Unhandled exit code '${exit_code}'. Error output: '${error_output}'. Attempting to continue ..."
            return 1
            ;;
        esac
    }

    setup_temporary_sudo_timeout() {
        if [ "${TEMPORARY_SUDO_SETUP_DONE}" = true ]; then
            return
        fi
        TEMP_SUDOERS="/etc/sudoers.d/temporary_timeout"
        trap 'log log_message "INFO: Removing temporary sudoers file ('${TEMP_SUDOERS}') to restore the original sudoers configuration."; sudo_wrapper rm -f "${TEMP_SUDOERS}"' EXIT
        TEMPORARY_SUDO_SETUP_DONE=true
        log_message "INFO: Temporary sudo timeout set to 300 minutes (configured in '${TEMP_SUDOERS}')."
        sudo_wrapper sh -c "echo 'Defaults        timestamp_timeout=300' > ${TEMP_SUDOERS}"
        sudo_wrapper chmod 440 ${TEMP_SUDOERS}
    }

    handle_sudo_request() {
        local response
        local command=("${@}")

        case "${SUDO_MODE}" in
        ask)
            if ${is_pkg_manager_command}; then
                retry_text="[r] Retry with sudo (this and future '${PKG_MANAGER}' commands)"
            else
                retry_text="[r] Retry with sudo"
            fi

            log_message "WARNING: Command '${command[*]}' failed with error: '${error_output}'."
            echo
            read -r -p "How would you like to proceed?

            ${retry_text}
            [a] Automatically use sudo when needed  (this and future commands)
            [c] Continue without sudo (this command will be skipped)
            [q] Quit

            Enter your choice [r/a/c/q]: " response
            echo

            case "${response}" in
            [Rr])
                if ${is_pkg_manager_command}; then
                    PKG_MANAGER_PERMISSION=true
                fi
                log_message "INFO: Retrying command '${command[*]}' with sudo ..."
                log sudo "${command[@]}"
                ;;
            [Cc]) ;;
            [aA])
                SUDO_MODE=auto
                setup_temporary_sudo_timeout
                log_message "INFO: Retrying command '${command[*]}' with sudo (sudo-mode set to auto) ..."
                log sudo "${command[@]}"
                ;;
            *)
                log_message "INFO: Exiting."
                exit 0
                ;;
            esac
            ;;
        auto)
            setup_temporary_sudo_timeout
            if ${is_pkg_manager_command}; then
                PKG_MANAGER_PERMISSION=true
            fi
            log log_message "WARNING: Command '${command[*]}' failed with: '${error_output}'. Using sudo ..."
            log sudo "${command[@]}"
            ;;
        continue)
            log_message "WARNING: Command '${command[*]}' failed with: '${error_output}'. Continuing without sudo ..."
            ;;
        error)
            log_message "WARNING: Command '${command[*]}' failed with '${error_output}'. Sudo is required, but mode is set to 'error'."
            exit 1
            ;;
        esac
    }

    is_pkg_manager_command=$([ "${1}" == "${PKG_MANAGER}" ] && echo true || echo false)

    if [[ "${SUDO_MODE}" == "force" || ("${is_pkg_manager_command}" == true && "${PKG_MANAGER_PERMISSION}" == true) ]]; then
        log sudo "${command[@]}"
        return
    fi

    error_output=$("${command[@]}" 2>&1)
    exit_code=${?}

    if needs_sudo "${exit_code}" "${error_output}"; then
        handle_sudo_request "${command[@]}"
    fi
}

# Try to connect to github.com
check_connection() {
    if (bash -c "echo >/dev/tcp/github.com/443" &>/dev/null); then
        return 0
    else
        log_message "ERROR: No internet connection. This script requires internet access to download packages." nolog
    fi
}

# Checks for a new version of the installer script and prompts the user to update.
check_script_update() {
    local latest_url="https://github.com/wieluk/psychopy_linux_installer/releases/latest/download/psychopy_linux_installer"
    local current_version latest_version rerun_cmd

    # Extract version information from the current and latest scripts.
    current_version=$(grep -m 1 'Version:' "${0}" | sed 's/[^0-9.]//g')
    latest_version=$(curl -sL "${latest_url}" | grep -m 1 'Version:' | sed 's/[^0-9.]//g')

    if is_version_greater "${latest_version}" "${current_version}"; then
        echo -e "\nA new version (${latest_version}) of the installer script is available."
        echo "    🔹 Repository: https://github.com/wieluk/psychopy_linux_installer"
        echo "    🔹 Releases:   https://github.com/wieluk/psychopy_linux_installer/releases"
        echo "    🔹 Issues:   https://github.com/wieluk/psychopy_linux_installer/issues"
        echo

        local script_path
        script_path=$(readlink -f "${0}")

        read -r -p "Would you like to update? (y/n) " response
        echo
        if [[ "${response}" =~ ^[Yy]$ ]]; then
            log_message "INFO: Updating to version '${latest_version}' ..."

            # Download and replace the current script with the latest release.
            if curl -sLo "${script_path}" "${latest_url}"; then
                log_message "INFO: Update completed successfully."
                rerun_cmd=$(create_rerun_command)
                log_message "NOTE: To re-run the installer with the current settings, use: '${rerun_cmd}'"
                exit 0
            else
                log_message "WARNING: Failed to download the update. Continuing with the current version."
            fi
        fi
    fi
}

# Determines the operating system and its version.
detect_os_version() {
    OS_VERSION=""
    OS_VERSION_LINK=""
    OS_VERSION_FULL=""

    local major_version version ID VERSION_ID
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        if [ -n "${ID}" ] && [ -n "${VERSION_ID}" ]; then
            ID=$(echo "${ID}" | tr '[:upper:]' '[:lower:]')
            VERSION_ID=$(echo "${VERSION_ID}" | tr '[:upper:]' '[:lower:]')
            major_version=$(echo "${VERSION_ID}" | cut -d. -f1)

            OS_VERSION="${ID}-${major_version}"
            OS_VERSION_FULL="${ID}-${VERSION_ID}"
            if [ "${ID}" = "ubuntu" ]; then
                OS_VERSION_LINK="${ID}-${VERSION_ID}"
            else
                OS_VERSION_LINK="${OS_VERSION}"
            fi
            return
        fi
    fi

    if command -v lsb_release >/dev/null 2>&1; then
        ID=$(lsb_release -si | tr '[:upper:]' '[:lower:]')
        version=$(lsb_release -sr | tr '[:upper:]' '[:lower:]')
        major_version=$(echo "${version}" | cut -d. -f1)

        OS_VERSION="${ID}-${major_version}"
        OS_VERSION_FULL="${ID}-${major_version}"
        if [ "${ID}" = "ubuntu" ]; then
            OS_VERSION_LINK="${ID}-${version}"
        else
            OS_VERSION_LINK="${OS_VERSION}"
        fi
        return
    fi

    log_message "WARNING: Unable to detect OS version."
    OS_VERSION="unknown"
    OS_VERSION_LINK="unknown"
    OS_VERSION_FULL="unknown"
    return
}

# Identifies the available package manager (apt-get, yum, etc.).
detect_package_manager() {
    if command -v apt-get >/dev/null 2>&1; then
        echo "apt-get"
    elif command -v yum >/dev/null 2>&1; then
        echo "yum"
    elif command -v dnf >/dev/null 2>&1; then
        echo "dnf"
    elif command -v pacman >/dev/null 2>&1; then
        echo "pacman"
    elif command -v zypper >/dev/null 2>&1; then
        echo "zypper"
    else
        log_message "ERROR: No compatible package manager found."
    fi
}

# Updates the package manager's database.
update_package_manager() {
    case ${PKG_MANAGER} in
    apt-get) sudo_wrapper apt-get update -qq ;;
    yum) sudo_wrapper yum makecache -q ;;
    dnf) sudo_wrapper dnf makecache -q ;;
    pacman) log_message "WARNING: Skipping 'pacman -Syu' to avoid unintended system upgrades. If you encounter a lot of 'package not found' errors, manually run 'sudo pacman -Syu' to update your package database, then rerun this script." ;;
    zypper) sudo_wrapper zypper refresh ;;
    *)
        log_message "ERROR: No compatible package manager found."
        ;;
    esac
}

# Installs the provided packages via the identified package manager.
install_packages() {
    local packages=("${@}")

    # Try batch install first
    local available_packages
    read -r -a available_packages <<<"$(filter_installable_packages "${packages[@]}")"

    # Using grep to compute the difference between packages and available_packages
    diff=$(printf "%s\n" "${packages[@]}" | grep -vxFf <(printf "%s\n" "${available_packages[@]}") | paste -sd, -)
    [ -n "${diff}" ] && log_message "WARNING: The following packages are not available and will be skipped: '${diff}'"

    # Check if the available_packages array is empty
    if [ ${#available_packages[@]} -eq 0 ]; then
        log_message "WARNING: No valid packages found for installation."
        return
    fi

    if {
        case "${PKG_MANAGER}" in
        apt-get) sudo_wrapper apt-get install -y -qq "${available_packages[@]}" ;;
        yum) sudo_wrapper yum install -y -q "${available_packages[@]}" ;;
        dnf) sudo_wrapper dnf install -y -q "${available_packages[@]}" ;;
        pacman) sudo_wrapper pacman -S --needed --noconfirm "${available_packages[@]}" ;;
        zypper) sudo_wrapper zypper install -y "${available_packages[@]}" ;;
        *)
            log_message "ERROR: No compatible package manager found."
            ;;
        esac
    } then
        return 0
    else
        log_message "WARNING: Batch installation failed. Falling back to per-package installation. This might take sometime ..."
    fi

    # If batch install fails, fallback to installing packages one by one
    for package in "${packages[@]}"; do
        case ${PKG_MANAGER} in
        apt-get) sudo_wrapper apt-get install -y -qq "${package}" || log_message "WARNING: Package '${package}' not found, skipping." ;;
        yum) sudo_wrapper yum install -y -q "${package}" || log_message "WARNING: Package '${package}' not found, skipping." ;;
        dnf) sudo_wrapper dnf install -y -q "${package}" || log_message "WARNING: Package '${package}' not found, skipping." ;;
        pacman) sudo_wrapper pacman -S --needed --noconfirm "${package}" || log_message "WARNING: Package '${package}' not found, skipping." ;;
        zypper) sudo_wrapper zypper install -y "${package}" || log_message "WARNING: Package '${package}' not found, skipping." ;;
        *)
            log_message "ERROR: No compatible package manager found."
            ;;
        esac
    done
}

# Installs dependency groups (e.g. script_deps, python_build_deps, etc.).
install_dependencies() {
    local dep_type dependencies script_deps psychopy_deps fonts python_build_deps wxpython_deps python_with_venv

    dep_type="${1}"
    dependencies=()

    case ${PKG_MANAGER} in
    apt-get)
        script_deps=(curl git jq)
        psychopy_deps=(libasound2-dev libegl1-mesa-dev libglib2.0-dev libgtk-3-dev libnotify4 libusb-1.0-0-dev libwebkit2gtk-4.0-dev libwebkit2gtk-4.1-dev libxcb-cursor0 libxcb-xinerama0 libxkbcommon-x11-0 libsdl2-dev libglu1-mesa-dev portaudio19-dev pulseaudio pulseaudio-utils)
        fonts=(fonts-dejavu fonts-liberation fontconfig)
        python_build_deps=(build-essential libbz2-dev libffi-dev libreadline-dev libsqlite3-dev libssl-dev make xz-utils zlib1g-dev)
        wxpython_deps=(freeglut3-dev g++ gstreamer1.0-plugins-base gstreamer1.0-tools gstreamer1.0-x libgtk2.0-dev libjpeg-dev libnotify-dev libpng-dev libsm-dev libtiff-dev make)
        python_with_venv=(python3 python3-dev python3-pip python3-venv)
        ;;
    yum | dnf)
        script_deps=(curl git jq)
        psychopy_deps=(alsa-lib-devel gtk3-devel libnotify mesa-libEGL-devel mesa-libGLU-devel portaudio-devel pulseaudio pulseaudio-utils SDL2-devel webkit2gtk3-devel webkit2gtk4.0-devel libusb1-devel)
        fonts=(fontconfig dejavu-sans-fonts dejavu-serif-fonts liberation-sans-fonts liberation-serif-fonts liberation-mono-fonts)
        python_build_deps=(bzip2-devel gcc libffi-devel make openssl-devel readline-devel sqlite-devel xz-devel zlib-devel)
        wxpython_deps=(freeglut-devel gcc-c++ gstreamer1-devel gtk2-devel libSM-devel libjpeg-devel libjpeg-turbo-devel libnotify-devel libpng-devel libtiff-devel make glib2-devel)
        python_with_venv=(python3 python3-devel python3-pip python3-venv)
        ;;
    pacman)
        script_deps=(curl git jq)
        psychopy_deps=(alsa-lib gtk3 libnotify libusb mesa portaudio pulseaudio pulseaudio-utils SDL2 webkit2gtk xcb-util-cursor libxcb glu)
        fonts=(ttf-dejavu ttf-liberation noto-fonts gnu-free-fonts)
        python_build_deps=(base-devel bzip2 libffi make openssl readline sqlite xz zlib)
        wxpython_deps=(freeglut gcc glib2 gstreamer gtk2 libjpeg libpng libsm libtiff make mesa)
        python_with_venv=(python python-pip python-virtualenv)
        ;;
    zypper)
        script_deps=(curl git jq)
        psychopy_deps=(alsa-devel gtk3-devel libnotify4 libusb-1_0-devel libxcb-xinerama0 portaudio-devel pulseaudio pulseaudio-utils SDL2-devel)
        fonts=(dejavu-fonts liberation-fonts fontconfig)
        python_build_deps=(gcc libffi-devel libopenssl-devel make readline-devel sqlite3-devel xz-devel zlib-devel)
        wxpython_deps=(freeglut-devel gcc-c++ glib2-devel gstreamer-plugins-base libSM-devel libjpeg-turbo libnotify-devel libpng16-devel make libtiff-devel)
        python_with_venv=(python3 python3-devel python3-pip python3-virtualenv)
        ;;
    *)
        log_message "ERROR: No compatible package manager found."
        ;;
    esac

    case ${dep_type} in
    script_deps) dependencies=("${script_deps[@]}") ;;
    python_build_deps) dependencies=("${python_build_deps[@]}") ;;
    psychopy_deps) dependencies=("${psychopy_deps[@]}") ;;
    fonts) dependencies=("${fonts[@]}") ;;
    wxpython_deps) dependencies=("${wxpython_deps[@]}") ;;
    python_with_venv) dependencies=("${python_with_venv[@]}") ;;
    *)
        log_message "ERROR: Invalid dependency type specified."
        ;;
    esac

    install_packages "${dependencies[@]}"
}

# Filters and returns a list of packages available for installation.
filter_installable_packages() {
    local filtered_packages=()

    for package in "${@}"; do
        # Skip conflicting packages for specific OS versions
        case "${OS_VERSION}" in
        ubuntu-24) [[ "${package}" == "libwebkit2gtk-4.0-dev" ]] && continue ;;
        ubuntu-20) [[ "${package}" == "libwebkit2gtk-4.1-dev" ]] && continue ;;
        debian-11) [[ "${package}" == "libwebkit2gtk-4.1-dev" ]] && continue ;;
        pop-22) [[ "${package}" == "pulseaudio" ]] && continue ;;
        fedora-39 | fedora-40 | fedora-41) [[ "${package}" == "pulseaudio" ]] && continue ;;
        rocky-9 | centos-9) [[ "${package}" == "pulseaudio" || "${package}" == "portaudio-devel" ]] && continue ;;
        linuxmint-22) [[ "${package}" == "libwebkit2gtk-4.0-dev" ]] && continue ;;
        manjarolinux-25) [[ "${package}" == "pulseaudio-utils" || "${package}" == "pulseaudio" ]] && continue ;;
        esac

        case "${PKG_MANAGER}" in
        apt-get)
            if apt-cache show "${package}" &>/dev/null; then
                filtered_packages+=("${package}")
            fi
            ;;
        yum | dnf)
            if ${PKG_MANAGER} info "${package}" &>/dev/null; then
                filtered_packages+=("${package}")
            fi
            ;;
        pacman)
            if pacman -Si "${package}" &>/dev/null; then
                filtered_packages+=("${package}")
            fi
            ;;
        zypper)
            if zypper search --match-exact "${package}" &>/dev/null; then
                filtered_packages+=("${package}")
            fi
            ;;
        esac
    done
    echo "${filtered_packages[@]}"
}

# Verifies if the specific Python version is available through the package manager.
check_python_in_package_manager() {
    local available_version

    case ${PKG_MANAGER} in
    apt-get)
        available_version=$(apt-cache policy python3 | grep -m 1 "Candidate:" | awk '{print $2}' | cut -d'.' -f1,2)
        ;;
    yum)
        available_version=$(yum info python3 2>/dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
        ;;
    dnf)
        available_version=$(dnf info python3 2>/dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
        ;;
    pacman)
        available_version=$(pacman -Si python 2>/dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
        ;;
    zypper)
        available_version=$(zypper info python3 2>/dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
        ;;
    *)
        log_message "ERROR: No compatible package manager found."
        ;;
    esac

    if [ "${available_version}" == "${PYTHON_VERSION}" ]; then
        return 0
    else
        log_message "WARNING: 'Python${PYTHON_VERSION}' not available in '${PKG_MANAGER}'."
        return 1
    fi
}

# Compares two version strings and returns true if the first is greater.
is_version_greater() {
    if [[ "${1}" =~ ^[0-9]+(\.[0-9]+)*$ ]] && [[ "${2}" =~ ^[0-9]+(\.[0-9]+)*$ ]]; then
        [ "$(printf '%s\n' "${@}" | sort -V | head -n 1)" != "${1}" ]
    else
        return 1
    fi
}

# Retrieves and sorts available versions for a package from PyPI.
fetch_versions_from_pypi() {
    local package="${1}"
    curl -s "https://pypi.org/pypi/${package}/json" | jq -r '.releases // {} | keys[]' | sort -Vr
}

# Retrieves the latest version for a package from PyPI.
get_latest_pypi_version() {
    local pkg="${1}"
    local var_name="${2}"

    local version
    version=$(curl -s "https://pypi.org/pypi/${pkg}/json" | jq -r '.info.version')
    if [ -z "${version}" ] || [ "${version}" = "null" ]; then
        log_message "ERROR: Unable to fetch the latest version for package '${package_name}'."
    fi
    declare -n result=${var_name}
    # shellcheck disable=SC2034
    result="${version}"
}

# Converts a PsychoPy package spec to the appropriate Git URL if needed.
convert_psychopy_req_to_git_url() {
    local package_spec="${1}"

    if [[ ! ${package_spec} =~ ^psychopy== ]] || [ "${PSYCHOPY_GIT_TAG}" != "true" ]; then
        echo "${package_spec}"
        return 0
    fi

    local version=${package_spec#psychopy==}
    echo "git+https://github.com/psychopy/psychopy.git@${version}"
}

# Verifies that the requested package version exists on PyPI (or Git).
check_pypi_for_version() {
    local package="${1}"
    local version="${2}"
    local github_api="https://api.github.com/repos/psychopy/psychopy/git/refs/tags"
    local pypi_api="https://pypi.org/pypi"

    if curl -s "${pypi_api}/${package}/${version}/json" | jq -e .info.version >/dev/null; then
        return 0
    fi

    if [ "${package}" = "psychopy" ]; then
        if curl -s -H "Accept: application/vnd.github.v3+json" \
            "${github_api}/${version}" | jq -e .ref >/dev/null; then
            log_message "WARNING: '${package}' version '${version}' not found on PyPi but as GitHub tag"
            PSYCHOPY_GIT_TAG=true
            return 0
        fi
    fi

    log_message "ERROR: '${package}' version '${version}' not found on PyPI." nolog
}

# Confirms that Python, pip, and venv are available.
check_python_env() {
    local python_cmd="${1}"
    if ! command -v "${python_cmd}" >/dev/null 2>&1; then
        log_message "ERROR: '${python_cmd}' not found. Something went wrong while installing/building. Try '--build=python' as argument."
    fi

    if ! "${python_cmd}" -m venv --help >/dev/null 2>&1; then
        log_message "ERROR: '${python_cmd}' found, but venv module is not available. Something went wrong while installing/building. Try '--build=python' as argument."
    fi

    if ! "${python_cmd}" -m pip --version >/dev/null 2>&1; then
        log_message "ERROR: '${python_cmd}' found, but pip is not installed. Something went wrong while installing/building. Try '--build=python' as argument."
    fi
}

# Builds Python from source, using the specified version.
build_python() {
    local official_base_url latest_patch_version official_url temp_file temp_dir
    log_message "INFO: Building 'Python${PYTHON_VERSION}' from source. This may take some time ..."
    official_base_url="https://www.python.org/ftp/python/"

    latest_patch_version=$(curl -s "${official_base_url}" | grep -oP "${PYTHON_VERSION}\.[0-9]+/" | sort -V | tail -n 1 | sed 's:/$::')

    official_url="${official_base_url}${latest_patch_version}/Python-${latest_patch_version}.tgz"
    temp_file="Python-${latest_patch_version}.tgz"
    temp_dir="Python-${latest_patch_version}_temp"

    if ! log curl -L -o "${temp_file}" "${official_url}"; then
        log_message "ERROR: Failed to download Python source from '${official_url}'."
    fi

    mkdir -p "${temp_dir}" || {
        log_message "ERROR: Failed to create '${temp_dir}'."
    }

    if ! tar -xf "${temp_file}" -C "${temp_dir}"; then
        log_message "ERROR: Failed to extract '${temp_file}'."
    fi

    cd "${temp_dir}/Python-${latest_patch_version}" || {
        log_message "ERROR: Failed to change directory."
    }
    log ./configure --enable-optimizations --with-ensurepip=install --prefix=/usr/local/psychopy_python
    log make -j "$(nproc)"
    sudo_wrapper make altinstall
    cd "${PSYCHOPY_DIR}" || {
        log_message "ERROR: Failed to return to '${PSYCHOPY_DIR}'."
    }

    sudo_wrapper rm -rf "${temp_dir}" "${temp_file}"
    return 0
}

# Attempts to install Python from a GitHub release asset.
install_python_from_github() {
    local asset_name api_url github_api_header assets_json temp_file temp_dir github_download_url python_version_pattern latest_release_tag

    github_api_header="Accept: application/vnd.github.v3+json"
    latest_release_tag=$(curl -s -H "${github_api_header}" "https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest" | jq -r .tag_name)
    api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/tags/v${SCRIPT_VERSION}"
    assets_json=$(curl -s -H "${github_api_header}" "${api_url}")

    python_version_pattern="python-${PYTHON_VERSION}\.[0-9]+-${PROCESSOR_STRUCTURE}-${OS_VERSION}\.tar\.gz"
    asset_name=$(echo "${assets_json}" | jq -r '.assets // [] | .[].name' | grep -E "${python_version_pattern}" | sort -V | tail -n 1)

    # If no matching asset is found AND the script version is NOT the latest, check the latest release
    if [[ -z "${asset_name}" && "v${SCRIPT_VERSION}" != "${latest_release_tag}" ]]; then
        log_message "WARNING: No matching Python version found in 'v${SCRIPT_VERSION}'. Checking the latest release '${latest_release_tag}' ..."
        api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest"
        assets_json=$(curl -s -H "${github_api_header}" "${api_url}")
        asset_name=$(echo "${assets_json}" | jq -r '.assets // [] | .[].name' | grep -E "${python_version_pattern}" | sort -V | tail -n 1)
    fi

    if [ -z "${asset_name}" ]; then
        log_message "WARNING: No matching Python version found in 'v${SCRIPT_VERSION}' or latest release '${latest_release_tag}' for Python${PYTHON_VERSION}."
        return 1
    fi

    github_download_url=$(echo "${assets_json}" | jq -r --arg name "${asset_name}" '.assets // [] | .[] | select(.name == $name) | .browser_download_url')

    if [ -z "${github_download_url}" ]; then
        log_message "WARNING: Could not find a download URL for asset '${asset_name}'."
        return 1
    fi

    log_message "INFO: Downloading '${asset_name}' from GitHub ..."
    if log curl -L -o "${asset_name}" "${github_download_url}"; then
        log_message "INFO: Successfully downloaded '${asset_name}' from GitHub release 'v${SCRIPT_VERSION}'. Making an altinstall ..."
        temp_dir="${asset_name%.tar.gz}_temp"
        mkdir -p "${temp_dir}" || {
            log_message "WARNING: Failed to create '${temp_dir}'."
            return 1
        }

        if tar -xf "${asset_name}" -C "${temp_dir}"; then
            cd "${temp_dir}" || {
                log_message "WARNING: Failed to change directory."
                return 1
            }
            sudo_wrapper make altinstall
            cd "${PSYCHOPY_DIR}" || {
                log_message "WARNING: Failed to return to '${PSYCHOPY_DIR}'."
                return 1
            }
            sudo_wrapper rm -rf "${temp_dir}" "${asset_name}"
            return 0
        else
            log_message "WARNING: Failed to extract '${asset_name}'."
            sudo_wrapper rm -rf "${temp_dir}"
            return 1
        fi
    else
        log_message "WARNING: Failed to download from GitHub release."
        return 1
    fi
}

# Builds wxPython from source with the necessary build dependencies.
build_wxpython() {
    local tmp_size_gb

    log_message "INFO: Installing wxPython build dependencies. This might take a while ..."
    install_dependencies wxpython_deps

    # Check /tmp size and warn if ≤2GB
    tmp_size_gb=$(df -B1G --output=size /tmp 2>/dev/null | tail -n1 | tr -d ' ' || echo 0)
    [ "${tmp_size_gb}" -le 2 ] && log_message "WARNING: /tmp is only '${tmp_size_gb}GB'. wxPython build may fail. Please increase your '/tmp' size."

    log_message "INFO: Building wxPython ${WXPYTHON_VERSION} from source. This might take a while ..."
    if log "${PYTHON_VENV_COMMAND}" -m pip install --no-binary=wxpython --no-cache-dir --force-reinstall "wxpython==${WXPYTHON_VERSION}"; then
        log_message "INFO: Successfully built wxPython from source."
    else
        log_message "ERROR: Building wxPython from source failed."
    fi
}

# Attempts to install wxPython from a GitHub released wheel.
install_wxpython_from_github() {
    local api_url assets_json latest_release_tag github_api_header wheel_name renamed_wheel download_url python_version_major_minor

    github_api_header="Accept: application/vnd.github.v3+json"
    latest_release_tag=$(curl -s -H "${github_api_header}" "https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest" | jq -r .tag_name)
    api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/tags/v${SCRIPT_VERSION}"
    assets_json=$(curl -s -H "${github_api_header}" "${api_url}")

    python_version_major_minor=$(echo "${PYTHON_VERSION}" | awk -F. '{printf "%s%s", $1, $2}')
    wheel_name="wxPython-${WXPYTHON_VERSION}-cp${python_version_major_minor}-cp${python_version_major_minor}-${PROCESSOR_STRUCTURE}-${OS_VERSION}.whl"
    download_url=$(echo "${assets_json}" | jq -r --arg name "${wheel_name}" '.assets // [] | .[] | select(.name == $name) | .browser_download_url')

    # If no matching wheel is found AND the script version is NOT the latest, check the latest release
    if [[ -z "${download_url}" && "v${SCRIPT_VERSION}" != "${latest_release_tag}" ]]; then
        log_message "INFO: No matching wxPython wheel found in 'v${SCRIPT_VERSION}'. Checking the latest release '${latest_release_tag}' ..."
        api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest"
        assets_json=$(curl -s -H "${github_api_header}" "${api_url}")
        download_url=$(echo "${assets_json}" | jq -r --arg name "${wheel_name}" '.assets // [] | .[] | select(.name == $name) | .browser_download_url')
    fi

    if [ -z "${download_url}" ]; then
        log_message "WARNING: No matching wxPython wheel found in 'v${SCRIPT_VERSION}' or latest release '${latest_release_tag}' for 'wxPython ${WXPYTHON_VERSION}'."
        return 1
    fi

    log_message "INFO: Downloading '${wheel_name}' from GitHub ..."
    if log curl -L -o "${wheel_name}" "${download_url}"; then
        log_message "INFO: Successfully downloaded wxPython wheel from GitHub release. Installing wxPython from '${wheel_name}' ..."
        renamed_wheel="${wheel_name%-"${OS_VERSION}".whl}.whl"
        mv "${wheel_name}" "${renamed_wheel}"
        if log "${PYTHON_VENV_COMMAND}" -m pip install "${renamed_wheel}"; then
            log_message "INFO: Installed wxPython from '${renamed_wheel}'"
            sudo_wrapper mkdir -p /usr/local/psychopy_python/wx_wheels
            sudo_wrapper mv "${renamed_wheel}" /usr/local/psychopy_python/wx_wheels/
            return 0
        else
            log_message "WARNING: Installing wxPython from '${renamed_wheel}' failed."
            rm "${renamed_wheel}"
            return 1
        fi
    else
        log_message "WARNING: Downloading '${wheel_name}' failed."
        return 1
    fi
}

# Creates desktop shortcuts for PsychoPy applications.
create_desktop_shortcut() {
    local desktop_shortcut desktop_dir psychopy_exec resources_dir desktop_content
    desktop_dir="${HOME}/.local/share/applications"
    psychopy_exec="${PSYCHOPY_DIR}/bin/psychopy"
    resources_dir="${PSYCHOPY_DIR}/Resources"
    local shortcuts=()

    if ! desktop_shortcut="$(xdg-user-dir DESKTOP 2>/dev/null)"; then
        log_message "WARNING: xdg-user-dir not found. Desktop shortcut creation failed."
        return
    fi

    shortcuts+=(
        "--no-splash" "$(basename "${PSYCHOPY_DIR}")" "psychopy.png"
        "--builder --no-splash" "Builder $(basename "${PSYCHOPY_DIR}")" "builder.png"
        "--coder --no-splash" "Coder $(basename "${PSYCHOPY_DIR}")" "coder.png"
    )

    if [ ! -d "${desktop_shortcut}" ]; then
        log_message "WARNING: Desktop directory '${desktop_shortcut}' does not exist. Skipping shortcut creation."
        return
    fi

    mkdir -p "${resources_dir}"

    for ((i = 0; i < ${#shortcuts[@]}; i += 3)); do
        local exec_args="${shortcuts[i]}"
        local pretty_name="${shortcuts[i + 1]}"
        local icon_file="${shortcuts[i + 2]}"
        local icon_url="https://raw.githubusercontent.com/wieluk/psychopy_linux_installer/main/Resources/${icon_file}"
        local desktop_file="${desktop_shortcut}/${pretty_name}.desktop"
        local icon_path="${resources_dir}/${icon_file}"

        if curl --output /dev/null --silent --head --fail "${icon_url}"; then
            log curl -s -o "${icon_path}" "${icon_url}"
        else
            log_message "WARNING: Icon file '${icon_url}' not found, skipping ..."
        fi

        local icon_line=""
        [ -f "${icon_path}" ] && icon_line="Icon=${icon_path}"

        desktop_content=$(printf "%s\n" \
            "[Desktop Entry]" \
            "Version=1.0" \
            "Type=Application" \
            "Name=${pretty_name}" \
            "GenericName=PsychoPy Experiment Builder" \
            "Comment=Run PsychoPy ${PSYCHOPY_VERSION} on Python${PYTHON_VERSION} with ${exec_args}" \
            "Exec=${psychopy_exec} ${exec_args}" \
            "${icon_line}" \
            "Terminal=false" \
            "Categories=Education;Science;Development;" \
            "MimeType=application/x-psyexp;" \
            "Keywords=psychopy;experiment;builder;psyexp;design;" \
            "TryExec=${psychopy_exec}" \
            "StartupNotify=true" \
            "StartupWMClass=PsychoPy")

        sh -c "echo '${desktop_content}' > '${desktop_file}'"
        sudo_wrapper chmod +x "${desktop_file}"
        sudo_wrapper chown "${USER}" "${desktop_file}"

        if command -v gio >/dev/null 2>&1; then
            gio set "${desktop_file}" metadata::trusted true
        fi

        sudo_wrapper ln -sf "${desktop_file}" "${desktop_dir}/${pretty_name}.desktop"
    done
    log_message "INFO: Desktop shortcuts created successfully."
}

# Adds the PsychoPy installation's bin directory to the user's PATH.
add_psychopy_to_path() {
    local shell_name target_bin
    local bin_dir="${PSYCHOPY_DIR}/.bin"

    target_bin="${bin_dir}/$(basename "${PSYCHOPY_DIR}")"
    shell_name=$(basename "${SHELL}")

    mkdir -p "${bin_dir}"
    ln -sf "${PSYCHOPY_DIR}/bin/psychopy" "${target_bin}"

    local config_file=""
    local path_line=""

    case ${shell_name} in
    bash)
        config_file="${HOME}/.bashrc"
        path_line="export PATH=\"${bin_dir}:\${PATH}\""
        ;;
    zsh)
        config_file="${HOME}/.zshrc"
        path_line="export PATH=\"${bin_dir}:\${PATH}\""
        ;;
    fish)
        config_file="${HOME}/.config/fish/config.fish"
        path_line="set -gx PATH \"${bin_dir}\" \${PATH}"
        ;;
    csh | tcsh)
        config_file="${HOME}/.${shell_name}rc"
        path_line="setenv PATH ${bin_dir}:\${PATH}"
        ;;
    *)
        log_message "WARNING: Unsupported shell: '${shell_name}'; PsychoPy not added to path"
        ;;
    esac

    if ! grep -Fxq "${path_line}" "${config_file}"; then
        sh -c "echo '${path_line}' >> \"${config_file}\""
        log_message "INFO: Added PsychoPy to the PATH in '${config_file}'."
    else
        log_message "INFO: PsychoPy is already in the PATH in '${config_file}'."
    fi
    log_message "NOTE: To update your PATH, run 'source ${config_file}' or restart your terminal."
    log_message "NOTE: To start PsychoPy from the system path, use: '$(basename "${PSYCHOPY_DIR}")'"
}

main() {
    local use_gui tmp_log_file final_log_file rerun_cmd
    PKG_MANAGER_PERMISSION=false
    PSYCHOPY_GIT_TAG=false
    TEMPORARY_SUDO_SETUP_DONE=false
    use_gui=false

    tmp_log_file="/tmp/psychopy_linux_installer_$(date +%Y%m%d_%H%M%S).log"
    LOG_FILE="${tmp_log_file}"
    log_message "NOTE: Logging to temporary file: '${LOG_FILE}'"

    check_connection

    for arg in "${@}"; do
        if [[ "${arg}" == "--gui" ]]; then
            if [[ "${#}" -eq 1 ]]; then
                use_gui=true
            else
                log_message "ERROR: The --gui option must be used alone without any other arguments." nolog
            fi
            break
        fi
    done

    if ${use_gui}; then
        if ! command -v zenity &>/dev/null; then
            log_message "ERROR: zenity is not installed or not available in PATH. Cannot use GUI mode." nolog
        else
            show_gui
        fi
    else
        process_arguments "${@}"
    fi

    if [ -n "${REQUIREMENTS_FILE}" ]; then
        log_message "INFO: Parsing requirements file: '${REQUIREMENTS_FILE}' ..."
        parse_requirements_file "${REQUIREMENTS_FILE}"
    fi

    # Ensure defaults for unset variables
    for key in "${!DEFAULT_OPTS[@]}"; do
        if [ -z "${!key+x}" ]; then
            eval "${key}='${DEFAULT_OPTS[${key}]}'"
        fi
    done

    VENV_NAME=${VENV_NAME//[[:space:]]/_}

    if ${use_gui}; then
        rerun_cmd=$(create_rerun_command)
        log_message "NOTE: To re-run the installer with the current --gui settings, use: '${rerun_cmd}'"
        echo
    fi

    # Detect OS version, architecture and script version
    detect_os_version
    PROCESSOR_STRUCTURE=$(uname -s | tr '[:upper:]' '[:lower:]')_$(uname -m)
    SCRIPT_VERSION=$(grep -m 1 'Version:' "$0" | sed 's/[^0-9.]//g')
    log_message "INFO: Initiating PsychoPy-${PSYCHOPY_VERSION} installation using psychopy_linux_installer(${SCRIPT_VERSION}) on ${OS_VERSION_FULL} (${PROCESSOR_STRUCTURE})."

    # Detect package manager
    PKG_MANAGER=$(detect_package_manager)

    # Update package manager
    log_message "INFO: Updating '${PKG_MANAGER}' package manager."
    update_package_manager "${PKG_MANAGER}"

    # Install basic dependencies
    log_message "INFO: Installing 'git', 'curl', and 'jq'."
    install_dependencies script_deps

    # Check for script update
    if [ "${NON_INTERACTIVE}" = false ]; then
        check_script_update
    fi

    # Determine PsychoPy version to install
    if [ "${PSYCHOPY_VERSION}" == "latest" ]; then
        get_latest_pypi_version "psychopy" PSYCHOPY_VERSION
    elif [ "${PSYCHOPY_VERSION}" != "git" ]; then
        check_pypi_for_version psychopy "${PSYCHOPY_VERSION}"
    fi

    # Set up PsychoPy installation directory
    INSTALL_DIR="${INSTALL_DIR/#\~/${HOME}}"
    INSTALL_DIR="${INSTALL_DIR%/}"
    if [ -n "${VENV_NAME}" ]; then
        PSYCHOPY_DIR="${INSTALL_DIR}/${VENV_NAME}"
    else
        PSYCHOPY_DIR="${INSTALL_DIR}/PsychoPy-${PSYCHOPY_VERSION}-Python${PYTHON_VERSION}"
    fi

    if [ -d "${PSYCHOPY_DIR}" ]; then
        if [ "${FORCE_OVERWRITE}" = true ]; then
            log_message "WARNING: Directory '${PSYCHOPY_DIR}' already exists. Overwriting ..."
            sudo_wrapper rm -rf "${PSYCHOPY_DIR}"
            sudo_wrapper mkdir -p "${PSYCHOPY_DIR}"
        else
            log_message "ERROR: Directory '${PSYCHOPY_DIR}' already exists. Use the --force-overwrite flag to overwrite."
        fi
    else
        log_message "INFO: Creating PsychoPy directory at '${PSYCHOPY_DIR}' ..."
        sudo_wrapper mkdir -p "${PSYCHOPY_DIR}"
    fi

    [ -w "${PSYCHOPY_DIR}" ] || sudo_wrapper chown "${USER}" "${PSYCHOPY_DIR}"

    if ! [ -w "${PSYCHOPY_DIR}" ] || ! cd "${PSYCHOPY_DIR}"; then
        log_message "ERROR: Failed to access or change directory to '${PSYCHOPY_DIR}'."
    fi

    # Transition logs into psychopy_dir while keeping the same filename
    final_log_file="${PSYCHOPY_DIR}/$(basename "${tmp_log_file}")"

    if [ -f "${tmp_log_file}" ]; then
        mv "${tmp_log_file}" "${final_log_file}"
    fi
    LOG_FILE="${final_log_file}"
    log_message "NOTE: Installation directory set. Log file moved to: '${LOG_FILE}'."

    # Install PsychoPy dependencies
    log_message "INFO: Installing PsychoPy dependencies. This might take a while ..."
    install_dependencies psychopy_deps

    # Install python and create venv
    if [ "${BUILD_PYTHON}" = true ] || ! check_python_in_package_manager; then
        if [ "${BUILD_PYTHON}" = true ]; then
            log_message "INFO: Installing Python build dependencies ..."
            install_dependencies python_build_deps
            build_python
        else
            if [ -x "/usr/local/psychopy_python/bin/python${PYTHON_VERSION}" ]; then
                log_message "INFO: 'Python${PYTHON_VERSION}' is already installed in '/usr/local/psychopy_python'. Skipping installation."
            else
                log_message "INFO: Installing Python build dependencies ..."
                install_dependencies python_build_deps
                if install_python_from_github; then
                    :
                else
                    build_python
                fi
            fi
        fi

        check_python_env "/usr/local/psychopy_python/bin/python${PYTHON_VERSION}"
        if [ ! -x "/usr/local/psychopy_python/bin/python${PYTHON_VERSION}" ]; then
            log_message "ERROR: 'python${PYTHON_VERSION}' not found in '/usr/local/psychopy_python'. Something went wrong while installing/building. You can try '--build=python'."
        fi
        export PATH=/usr/local/psychopy_python/bin:$PATH
        /usr/local/psychopy_python/bin/python"${PYTHON_VERSION}" -m venv "${PSYCHOPY_DIR}"
    else
        log_message "INFO: 'Python${PYTHON_VERSION}' can be installed via package manager. Installing ..."
        install_dependencies python_with_venv
        check_python_env "python${PYTHON_VERSION}"
        python"${PYTHON_VERSION}" -m venv "${PSYCHOPY_DIR}"
    fi

    log_message "INFO: Successfully created 'Python${PYTHON_VERSION}' venv in '${PSYCHOPY_DIR}'."
    PYTHON_VENV_COMMAND="${PSYCHOPY_DIR}/bin/python"
    check_python_env "${PYTHON_VENV_COMMAND}"

    # Upgrade pip and install required Python packages
    log_message "INFO: Upgrading 'pip', 'distro', 'sip', 'six', 'psychtoolbox', 'attrdict', 'setuptools', 'wheel' ..."
    log "${PYTHON_VENV_COMMAND}" -m pip install -U pip distro sip six psychtoolbox setuptools wheel
    if [[ "${PYTHON_VERSION}" == "3.8" || "${PYTHON_VERSION}" == "3.9" ]]; then
        log "${PYTHON_VENV_COMMAND}" -m pip install -U attrdict
    elif [[ "${PYTHON_VERSION}" == "3.10" ]]; then
        log "${PYTHON_VENV_COMMAND}" -m pip install -U attrdict3
    fi

    # Determine wxPython version and install it
    log_message "INFO: Installing wxpython '${WXPYTHON_VERSION}' ..."
    if [ "${WXPYTHON_VERSION}" = "latest" ]; then
        get_latest_pypi_version "wxPython" WXPYTHON_VERSION
    elif [ "${WXPYTHON_VERSION}" != "git" ]; then
        check_pypi_for_version wxpython "${WXPYTHON_VERSION}"
    fi

    if [ "${WXPYTHON_VERSION}" = "git" ]; then
        log_message "INFO: Installing wxPython build dependencies. This might take a while ..."
        install_dependencies wxpython_deps
        log_message "INFO: Building wxPython from git. This might take a while ..."
        log "${PYTHON_VENV_COMMAND}" -m pip install git+https://github.com/wxWidgets/Phoenix
    elif [ "${BUILD_WX}" = true ]; then
        build_wxpython
    else
        if log "${PYTHON_VENV_COMMAND}" -m pip install --only-binary=:all: --find-links /usr/local/psychopy_python/wx_wheels/ "wxpython==${WXPYTHON_VERSION}"; then
            log_message "INFO: Successfully installed wxPython '${WXPYTHON_VERSION}' from local wheel."
        elif log "${PYTHON_VENV_COMMAND}" -m pip install --only-binary=:all: --find-links "https://extras.wxpython.org/wxPython4/extras/linux/gtk3/${OS_VERSION_LINK}/" "wxPython==${WXPYTHON_VERSION}"; then
            log_message "INFO: Successfully installed wxPython '${WXPYTHON_VERSION}' from extras.wxpython.org."
        elif install_wxpython_from_github; then
            :
        else
            build_wxpython
        fi
    fi

    if ! "${PYTHON_VENV_COMMAND}" -m pip show wxPython &>/dev/null; then
        log_message "ERROR: wxPython is not installed. Something went wrong during the installation. You can try '--build=wxpython'."
    fi

    if [ -n "${REQUIREMENTS_FILE}" ]; then
        log_message "INFO: Installing packages from requirements file ..."
        transformed_packages=$(echo "${REQUIREMENTSFILE_PACKAGES}" | tr ',' '\n' | while read -r pkg; do
            convert_psychopy_req_to_git_url "${pkg}"
        done)

        if log "${PYTHON_VENV_COMMAND}" -m pip install -r <(echo "${transformed_packages}"); then
            log_message "INFO: Packages from '${REQUIREMENTS_FILE}' installed successfully."
        else
            log_message "WARNING: Failed to install packages from '${REQUIREMENTS_FILE}'. Installing packages one by one ..."
            IFS=',' read -ra PACKAGES <<<"${REQUIREMENTSFILE_PACKAGES}"
            for package in "${PACKAGES[@]}"; do
                log_message "INFO: Installing '${package}' ..."
                transformed_pkg=$(convert_psychopy_req_to_git_url "${package}")
                if log "${PYTHON_VENV_COMMAND}" -m pip install "${transformed_pkg}"; then
                    pkg_name="${package%%=*}"
                    installed_version=$("${PYTHON_VENV_COMMAND}" -m pip show "${pkg_name}" | grep Version | cut -d' ' -f2)
                    log_message "INFO: '${pkg_name}' version '${installed_version}' installed successfully."
                else
                    log_message "WARNING: Failed to install '${package}'. Skipping."
                fi
            done
        fi
    else
        # Install PsychoPy
        log_message "INFO: Installing PsychoPy '${PSYCHOPY_VERSION}' ..."
        if [ "${PSYCHOPY_VERSION}" == "git" ]; then
            log "${PYTHON_VENV_COMMAND}" -m pip install git+https://github.com/psychopy/psychopy.git@dev
        elif [ "${PSYCHOPY_GIT_TAG}" = "true" ]; then
            log "${PYTHON_VENV_COMMAND}" -m pip install "git+https://github.com/psychopy/psychopy.git@${PSYCHOPY_VERSION}"
        else
            log "${PYTHON_VENV_COMMAND}" -m pip install psychopy=="${PSYCHOPY_VERSION}"
        fi

        if ! "${PYTHON_VENV_COMMAND}" -m pip show psychopy &>/dev/null; then
            log_message "ERROR: PsychoPy installation failed."
        fi
    fi

    # Install additional packages if specified
    if [ -n "${ADDITIONAL_PACKAGES}" ]; then
        log_message "INFO: Installing additional packages ..."
        IFS=',' read -ra PACKAGES <<<"${ADDITIONAL_PACKAGES}"
        for package in "${PACKAGES[@]}"; do
            log_message "INFO: Installing '${package}' ..."
            if log "${PYTHON_VENV_COMMAND}" -m pip install "${package}"; then
                installed_version=$("${PYTHON_VENV_COMMAND}" -m pip show "${package%%=*}" | grep Version | cut -d' ' -f2)
                log_message "INFO: '${package%%=*}' version '${installed_version}' installed successfully."
            else
                log_message "WARNING: Failed to install '${package}'. Skipping."
            fi
        done
    fi

    # Install numpy<2 if PsychoPy version is less than 2024.2.0
    if is_version_greater "2024.2.0" "${PSYCHOPY_VERSION}"; then
        log_message "WARNING: PsychoPy version < 2024.2.0, installing numpy<2"
        log "${PYTHON_VENV_COMMAND}" -m pip install "numpy<2"
    fi

    # Install some basic fonts for PsychoPy
    log_message "INFO: Installing basic fonts for PsychoPy."
    install_dependencies fonts

    # Add user to the 'psychopy' group and set security limits
    log_message "INFO: Adding '${USER}' to the psychopy group and setting security limits in '/etc/security/limits.d/99-psychopylimits.conf'."
    sudo_wrapper groupadd --force psychopy
    sudo_wrapper usermod -a -G psychopy "${USER}"
    sudo_wrapper sh -c 'echo "@psychopy - nice -20\n@psychopy - rtprio 50\n@psychopy - memlock unlimited" > /etc/security/limits.d/99-psychopylimits.conf'
    log_message "NOTE: A system reboot is necessary to apply the security limits."

    # Remove .psychopy3
    if [ "${REMOVE_PSYCHOPY_SETTINGS}" = true ]; then
        if [ -d "${HOME}/.psychopy3" ]; then
            log_message "INFO: Removing existing '.psychopy3' directory."
            sudo_wrapper rm -rf "${HOME}/.psychopy3"
        fi
    elif [ "${NON_INTERACTIVE}" = false ]; then
        if [ -d "${HOME}/.psychopy3" ]; then
            echo
            read -r -p "Do you want to remove existing PsychoPy user settings in '${HOME}/.psychopy3'? (Retaining this folder can sometimes result in conflicts with plugins or non-default pip-installed packages.) [y/N] " response
            echo
            if [[ "${response}" =~ ^[Yy]$ ]]; then
                log_message "INFO: Removing existing '.psychopy3' directory."
                sudo_wrapper rm -rf "${HOME}/.psychopy3"
            else
                log_message "INFO: Skipped removing '.psychopy3' directory."
            fi
        fi
    fi

    # Create desktop shortcut
    if [ "${DISABLE_SHORTCUT}" = false ]; then
        create_desktop_shortcut
    fi

    # Add PsychoPy to PATH
    if [ "${DISABLE_PATH}" = false ]; then
        add_psychopy_to_path
    fi

    log_message "NOTE: To start PsychoPy using the absolute path, run: '${PSYCHOPY_DIR}/bin/psychopy'"

    if "${PSYCHOPY_DIR}/bin/psychopy" -v &>/dev/null; then
        log_message "INFO: PsychoPy installation completed successfully!"
    else
        log_message "ERROR: PsychoPy installation verification failed!"
    fi
}

main "${@}"
