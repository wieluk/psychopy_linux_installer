#!/bin/bash
# ==============================================================================
#  Title:         psychopy_linux_installer
#  Description:   This script installs PsychoPy with specified versions of
#                 Python, wxPython, and optional packages.
#  Author:        Lukas Wiertz
#  Date:          2025-03-20
#  Version:       1.5.2
#  License:       GNU General Public License v3.0
# ==============================================================================

# Define default values
declare -A DEFAULT_OPTS=(
    [PSYCHOPY_VERSION]="latest"
    [PYTHON_VERSION]="3.10"
    [WXPYTHON_VERSION]="4.2.2"
    [BUILD_PYTHON]=false
    [BUILD_WX]=false
    [INSTALL_DIR]="$HOME"
    [VENV_NAME]=""
    [ADDITIONAL_PACKAGES]=""
    [SUDO_MODE]="ask"
    [DISABLE_SHORTCUT]=false
    [DISABLE_PATH]=false
    [NON_INTERACTIVE]=false
    [FORCE_OVERWRITE]=false
    [VERBOSE]=false
)

# Displays usage information and available options.
show_help() {
    cat << EOF
Usage: ./psychopy_linux_installer [options]
Options:
  --psychopy-version=VERSION                    Specify PsychoPy version (default: ${DEFAULT_OPTS[PSYCHOPY_VERSION]}).
  --python-version=3.8|3.9|3.10                 Specify Python version (default: ${DEFAULT_OPTS[PYTHON_VERSION]}).
  --wxpython-version=VERSION                    Specify wxPython version (default: ${DEFAULT_OPTS[WXPYTHON_VERSION]}).
  --requirements-file=FILE                      Specify a requirements.txt file to define dependencies.
  --build=[python|wxpython|both]                Build Python and/or wxPython from source instead of downloading. Not recommended, only use if installation doesn't work as expected.
  --install-dir=DIR                             Specify installation directory (default: "${DEFAULT_OPTS[INSTALL_DIR]}").
  --venv-name=NAME                              Specify a custom name for the virtual environment folder. If omitted, a versioned subdirectory will be used by default.
  --additional-packages=PACKAGES                Specify additional pip packages to install. Format: package1==version,package2.
  --sudo-mode=[ask|auto|error|continue|force]   Control sudo usage. ask: confirm, auto: auto-confirm, error: exit if sudo needed, continue: continue without sudo, force: use sudo directly (default: ${DEFAULT_OPTS[SUDO_MODE]}).
  --disable-shortcut                            Disable desktop shortcut creation.
  --non-interactive                             Run the installer without user interaction. Sets sudo-mode to auto if not set.
  --disable-path                                Disable adding psychopy to system path.
  --gui                                         Launches the installer in GUI mode, allowing you to set arguments interactively. Any arguments provided via the command line will be ignored while in GUI mode.
  -f, --force-overwrite                         Force overwrite of existing installation directory.
  -v, --verbose                                 Enable verbose output for the terminal (logfile output is always verbose).
  -h, --help                                    Show this help message.
EOF
}

# Log message function that writes colored output to terminal and plain text to the log file.
log_message() {
    local reset="\033[0m" green="\033[32m" yellow="\033[33m" red="\033[31m" cyan="\033[36m"
    local timestamp formatted_message plain_message
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Disable colors if output is not a terminal.
    if [[ ! -t 1 ]]; then
        reset=""; green=""; yellow=""; red=""; cyan=""
    fi

    case "$1" in
        Info:*)
            formatted_message=$(printf "%s - %b%s%b" "$timestamp" "$green" "$1" "$reset")
            ;;
        Warning:*)
            formatted_message=$(printf "%s - %b%s%b" "$timestamp" "$yellow" "$1" "$reset")
            ;;
        Error:*)
            formatted_message=$(printf "%s - %b%s%b" "$timestamp" "$red" "$1" "$reset")
            ;;
        Note:*)
            formatted_message=$(printf "%s - %b%s%b" "$timestamp" "$cyan" "$1" "$reset")
            ;;
        *)
            formatted_message=$(printf "%s - %s" "$timestamp" "$1")
            ;;
    esac

    plain_message="$timestamp - $1"
    echo "$plain_message" >> "$LOG_FILE"
    printf "%s\n" "$formatted_message"
}

# Wrapper to control command output based on verbosity.
log() {
    if [ "$VERBOSE" = true ]; then
        "$@" 2>&1 | tee -a "$LOG_FILE"
        return "${PIPESTATUS[0]}"
    else
        "$@" >> "$LOG_FILE" 2>&1
        return $?
    fi
}

# Parses the command-line arguments and sets appropriate variables.
process_arguments() {
    local SUDO_MODE_SET BUILD_ARG
    SUDO_MODE_SET=false

    for arg in "$@"; do
        case $arg in
            --psychopy-version=*)
                PSYCHOPY_VERSION="${arg#*=}"
                ;;
            --python-version=*)
                PYTHON_VERSION="${arg#*=}"
                if [[ ! $PYTHON_VERSION =~ ^3\.(8|9|10)$ ]]; then
                    log_message "Error: Unsupported Python version '$PYTHON_VERSION'. Allowed versions are 3.8, 3.9, or 3.10."
                    exit 1
                fi
                ;;
            --wxpython-version=*)
                WXPYTHON_VERSION="${arg#*=}"
                ;;
            --additional-packages=*)
                ADDITIONAL_PACKAGES="${arg#*=}"
                ;;
            --requirements-file=*)
                REQUIREMENTS_FILE="${arg#*=}"
                ;;
            --build=*)
                BUILD_ARG="${arg#*=}"
                case $BUILD_ARG in
                    python)
                        BUILD_PYTHON=true
                        ;;
                    wxpython)
                        BUILD_WX=true
                        ;;
                    both)
                        BUILD_PYTHON=true
                        BUILD_WX=true
                        ;;
                    *)
                        log_message "Error: Invalid option for --build: $BUILD_ARG"
                        show_help
                        exit 1
                        ;;
                esac
                ;;
            --install-dir=*)
                INSTALL_DIR="${arg#*=}"
                ;;
            --venv-name=*)
                VENV_NAME="${arg#*=}"
                ;;
            --sudo-mode=*)
                SUDO_MODE="${arg#*=}"
                if [[ "$SUDO_MODE" != "ask" && "$SUDO_MODE" != "continue" && "$SUDO_MODE" != "auto" && "$SUDO_MODE" != "error"  && "$SUDO_MODE" != "force" ]]; then
                    log_message "Error: Invalid value for --sudo_mode. Valid options are 'ask', 'continue', 'auto', 'error' or 'force'."
                    exit 1
                fi
                SUDO_MODE_SET=true
                ;;
            --disable-shortcut)
                DISABLE_SHORTCUT=true
                ;;
            --disable-path)
                DISABLE_PATH=true
                ;;
            --non-interactive)
                NON_INTERACTIVE=true
                if [ "$SUDO_MODE_SET" = false ]; then
                    SUDO_MODE=auto
                fi
                ;;
            -f|--force-overwrite)
                FORCE_OVERWRITE=true
                ;;
            -v|--verbose)
                VERBOSE=true
                ;;
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                log_message "Error: Unknown option: $arg"
                show_help
                exit 1
                ;;
        esac
    done
}

# Launches a Zenity-based GUI to collect user input interactively.
show_gui() {
    local wxpython_versions psychopy_versions use_requirements options

    # Optional: Select requirements.txt
    if zenity --question --title="Use requirements.txt (optional)" \
        --text="Do you want to use a requirements.txt file?\n\nIf you don't know what this is, choose 'No' to proceed with manual setup." \
        --ok-label="Yes" --cancel-label="No"; then

        if REQUIREMENTS_FILE=$(zenity --file-selection --title="Select requirements.txt" --file-filter="requirements.txt | *.txt") && [ -n "$REQUIREMENTS_FILE" ]; then
            use_requirements=true
        else
            exit 1
        fi
    else
        use_requirements=false
    fi

    if [ "$use_requirements" = false ]; then
        # Select PsychoPy version
        psychopy_versions="$(fetch_versions_from_pypi psychopy) + git"
        IFS=' ' read -r -a psychopy_false_opts <<< "$(echo "$psychopy_versions" | xargs -I{} printf "FALSE %s " {})"
        if PSYCHOPY_VERSION=$(zenity --list --title="PsychoPy Version" --width=800 --height=500 \
                --text="Select the PsychoPy version:" \
                --radiolist --column="Select" --column="Version" \
                TRUE "${DEFAULT_OPTS[PSYCHOPY_VERSION]}" "${psychopy_false_opts[@]}" | tr -d '"') && [ -n "$PSYCHOPY_VERSION" ]; then
            PSYCHOPY_VERSION=$(echo "$PSYCHOPY_VERSION" | xargs)
            :
        else
            exit 1
        fi

        # Select Python version
        if PYTHON_VERSION=$(zenity --list --title="Select Python Version" --width=800 --height=500 \
                --text="Choose the Python version for this installation.\n\nPython ${DEFAULT_OPTS[PYTHON_VERSION]} is recommended for best compatibility." \
                --radiolist --column="Select" --column="Version" \
                TRUE "3.10" FALSE "3.9" FALSE "3.8") && [ -n "$PYTHON_VERSION" ]; then
            PYTHON_VERSION=$(echo "$PYTHON_VERSION" | xargs)
            :
        else
            exit 1
        fi

        # Select wxPython version
        wxpython_versions=$(fetch_versions_from_pypi wxPython)
        IFS=' ' read -r -a wxpython_false_opts <<< "$(echo "$wxpython_versions" | grep -v "${DEFAULT_OPTS[WXPYTHON_VERSION]}" | xargs -I{} printf "FALSE %s " {})"
        if WXPYTHON_VERSION=$(zenity --list --title="Select wxPython Version" --width=800 --height=500 \
                --text="Choose the wxPython version for this installation.\n\nVersion ${DEFAULT_OPTS[WXPYTHON_VERSION]} is recommended for most setups." \
                --radiolist --column="Select" --column="Version" \
                TRUE "${DEFAULT_OPTS[WXPYTHON_VERSION]}" "${wxpython_false_opts[@]}" | tr -d '"') && [ -n "$WXPYTHON_VERSION" ]; then
            WXPYTHON_VERSION=$(echo "$WXPYTHON_VERSION" | xargs)
            :
        else
            exit 1
        fi

        # Additional packages
        if ADDITIONAL_PACKAGES=$(zenity --entry --title="Additional Packages (optional)" --width=800 --height=500 \
            --text="Specify additional pip packages to install (comma-separated).\n\nExample: psychopy-bids,another-package==1.2.3,package3\n\nLeave empty for no additional packages\n\n" \
            --entry-text=""); then
            ADDITIONAL_PACKAGES=$(echo "$ADDITIONAL_PACKAGES" | xargs)
            :
        else
            exit 1
        fi
    fi

    # Installation directory
    if INSTALL_DIR=$(zenity --file-selection --directory --title="Select Installation Directory") && [ -n "$INSTALL_DIR" ]; then
        INSTALL_DIR=$(echo "$INSTALL_DIR" | xargs)
        :
    else
        exit 1
    fi

    # Prompt for custom virtual environment name
    if VENV_NAME=$(zenity --entry --title="Custom Virtual Environment Name (optional)" --width=800 --height=500 \
        --text="Enter a custom name for the virtual environment folder.\n\nIf left blank, the default versioned name will be used: psychopy_{PSYCHOPY_VERSION}_py{PYTHON_VERSION}.\n\nThis folder will be created inside:\n$INSTALL_DIR\n\nNote: Spaces in the name will be replaced with underscores.\n\n" \
        --entry-text=""); then
        VENV_NAME=$(echo "$VENV_NAME" | xargs)
        :
    else
        exit 1
    fi

    # Additional options with tooltips
    if options=$(zenity --list --checklist --title="Additional Options" --width=800 --height=500 \
            --text="Select additional options:" \
            --column="Select" --column="Option" \
            TRUE "Create desktop shortcuts" \
            TRUE "Add PsychoPy to system PATH" \
            FALSE "Run in non-interactive mode" \
            FALSE "Force overwrite of existing directory" \
            FALSE "Build Python from source" \
            FALSE "Build wxPython from source" \
            FALSE "Enable verbose output"); then
        :
    else
        exit 1
    fi

    if [[ $options == *"Build Python from source"* ]]; then
        BUILD_PYTHON=true
    fi

    if [[ $options == *"Build wxPython from source"* ]]; then
        BUILD_WX=true
    fi

    if [[ $options == *"Create desktop shortcuts"* ]]; then
        DISABLE_SHORTCUT=false
    else
        DISABLE_SHORTCUT=true
    fi

    if [[ $options == *"Add PsychoPy to system PATH"* ]]; then
        DISABLE_PATH=false
    else
        DISABLE_PATH=true
    fi

    if [[ $options == *"Force overwrite of existing directory"* ]]; then
        FORCE_OVERWRITE=true
    fi

    if [[ $options == *"Enable verbose output"* ]]; then
        VERBOSE=true
    fi

    if [[ $options == *"Run in non-interactive mode"* ]]; then
        NON_INTERACTIVE=true
        SUDO_MODE=auto
    else
        NON_INTERACTIVE=false
    fi

    if [[ $NON_INTERACTIVE == false ]]; then
        if SUDO_MODE=$(zenity --list --title="Sudo Mode" --width=800 --height=500 \
                --text="Select the desired sudo mode:\n\n \
                    ask: Prompt each time sudo is needed.\n \
                    auto: Automatically use sudo when required.\n \
                    error: Exit immediately if a command requires sudo.\n \
                    continue: Attempt to run commands without sudo. If they fail due to missing permissions, proceed without stopping.\n \
                    force: Always use sudo for commands that typically require it, without checking necessity.\n\n" \
                --radiolist --column="Select" --column="Mode" \
                TRUE "ask" FALSE "auto" FALSE "error" FALSE "continue" FALSE "force") && [ -n "$SUDO_MODE" ]; then
            :
        else
            exit 1
        fi
    fi
}

# Reconstructs a command string to re-run the installer with the current settings.
create_rerun_command() {
    local cmd lowercase_key curr def
    cmd=$(readlink -f "$0")
    for key in "${!DEFAULT_OPTS[@]}"; do
        [[ "$key" == "BUILD_PYTHON" || "$key" == "BUILD_WX" ]] && continue
        curr="${!key}"
        def="${DEFAULT_OPTS[$key]}"
        lowercase_key=$(echo "$key" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
        if [[ "$curr" != "$def" ]]; then
            if [[ "$curr" == "true" && "$def" == "false" ]]; then
                cmd+=" --$lowercase_key"
            elif [[ -n "$curr" ]]; then
                cmd+=" --$lowercase_key=$curr"
            fi
        fi
    done
    if [[ "$BUILD_PYTHON" == true && "$BUILD_WX" == true ]]; then
        cmd+=" --build=both"
    elif [[ "$BUILD_PYTHON" == true ]]; then
        cmd+=" --build=python"
    elif [[ "$BUILD_WX" == true ]]; then
        cmd+=" --build=wxpython"
    fi
    [ -n "$REQUIREMENTS_FILE" ] && cmd+=" --requirements-file=$REQUIREMENTS_FILE"
    echo "$cmd"
}

# Reads and parses a requirements file, adjusting dependency versions as needed.
parse_requirements_file() {
    local file current_version operator package_name package_version pkg_lower version original_spec new_spec
    local -A package_versions
    local -A package_operators
    file="$1"

    if [ ! -f "$file" ] || [ ! -s "$file" ] || [ ! -r "$file" ]; then
        log_message "Error: The requirements file '$file' is either missing, empty, or inaccessible. Exiting."
        exit 1
    fi

    while IFS= read -r line; do
        if [[ "$line" =~ ^# ]] || [[ -z "$line" ]]; then
            continue
        fi

        if [[ "$line" =~ ^([A-Za-z0-9._-]+)[[:space:]]*(>=|<=|==|~=|!=|>|<)[[:space:]]*([0-9][A-Za-z0-9._-]*) ]]; then
            package_name="${BASH_REMATCH[1],,}"
            operator="${BASH_REMATCH[2]}"
            package_version="${BASH_REMATCH[3]}"

            if [[ -n "${package_versions[$package_name]}" ]]; then
                current_version="${package_versions[$package_name]}"
                if [[ "$operator" == "==" || "${package_operators[$package_name]}" != "==" ]]; then
                    package_versions["$package_name"]="$package_version"
                    package_operators["$package_name"]="$operator"
                fi
            else
                package_versions["$package_name"]="$package_version"
                package_operators["$package_name"]="$operator"
            fi
        fi
    done < "$file"

    BACKUP_ADDITIONAL_PACKAGES=$(for pkg in "${!package_versions[@]}"; do
        if [[ "$pkg" != "wxpython" && "$pkg" != "psychopy" &&  "$pkg" != "winrt" && "$pkg" != "pywin32" && "$pkg" != "pypiwin32" && "$pkg" != "pywinhook" ]]; then
            echo "$pkg${package_operators[$pkg]}${package_versions[$pkg]}"
        else
            if [[ "$pkg" != "wxpython" && "$pkg" != "psychopy" ]]; then
            log_message "Warning: $pkg python package from requirements.txt not available for Linux, skipping" >&2
            fi
        fi
    done | tr '\n' ',' | sed 's/,$//')

    PYTHON_VERSION=$(grep -i -E '^# Python version:' "$file" | cut -d':' -f2 | xargs | cut -d'.' -f1,2 | tr -d '[:space:]' || true)
    WXPYTHON_VERSION="${package_versions["wxpython"]:-}"
    PSYCHOPY_VERSION="${package_versions["psychopy"]:-}"

    [[ -z "$PYTHON_VERSION" ]] && log_message "Warning: Python version not specified in requirements file. Using default: ${DEFAULT_OPTS[PYTHON_VERSION]}."
    [[ -z "$WXPYTHON_VERSION" ]] && log_message "Warning: wxPython version not specified in requirements file. Using default: ${DEFAULT_OPTS[WXPYTHON_VERSION]}."

    if [ -z "$PSYCHOPY_VERSION" ]; then
        log_message "Error: PsychoPy version not specified in requirements.txt. Exiting."
        exit 1
    else
        BACKUP_ADDITIONAL_PACKAGES="${BACKUP_ADDITIONAL_PACKAGES:+$BACKUP_ADDITIONAL_PACKAGES,}psychopy==$PSYCHOPY_VERSION"
    fi

    # Adjust Linux dependencies
    for pkg in pyglet python-vlc; do
        pkg_lower="${pkg,,}"
        if [[ -n "${package_versions[$pkg_lower]}" ]]; then
            version="${package_versions[$pkg_lower]}"
            original_spec="$pkg_lower${package_operators[$pkg_lower]}$version"
            new_spec="$pkg_lower>=$version"
            if [[ "$BACKUP_ADDITIONAL_PACKAGES" == *"$original_spec"* ]]; then
                BACKUP_ADDITIONAL_PACKAGES=${BACKUP_ADDITIONAL_PACKAGES//"$original_spec"/"$new_spec"}
                log_message "Warning: '$pkg' from  requirements file was installed with a more flexible version. '$original_spec' may be platform-specific and was adjusted to '$new_spec' for Linux PsychoPy compatibility. If needed, you can manually install the exact version in the PsychoPy venv." >&2
            fi
        fi
    done
}

# Manages sudo usage and command retries when permissions are insufficient.
sudo_wrapper() {
    local error_output exit_code
    local command=("$@")
    local is_pkg_manager_command=false

    needs_sudo() {
        local exit_code="$1"
        local error_output="$2"

        case $exit_code in
            0) return 1 ;;
            1|2|5|10|13|77|100|126|127) return 0 ;;
            *)
                log_message "Warning: Unhandled exit code $exit_code. Error output: $error_output. Trying to continue ..."
                return 1 ;;
        esac
    }

    setup_temporary_sudo_timeout() {
        if [ "$TEMPORARY_SUDO_SETUP_DONE" = true ]; then
            return
        fi
        TEMP_SUDOERS="/etc/sudoers.d/temporary_timeout"
        trap 'log log_message "Info: Removing temporary sudoers file ($TEMP_SUDOERS) to restore original sudoers configuration."; sudo_wrapper rm -f "$TEMP_SUDOERS"' EXIT
        TEMPORARY_SUDO_SETUP_DONE=true
        log_message "Info: Temporary sudo timeout set to 300 minutes (configured in $TEMP_SUDOERS)."
        sudo_wrapper sh -c "echo 'Defaults        timestamp_timeout=300' > $TEMP_SUDOERS"
        sudo_wrapper chmod 440 $TEMP_SUDOERS
    }

    handle_sudo_request() {
        local response
        local command=("$@")

        case "$SUDO_MODE" in
            ask)
                if $is_pkg_manager_command; then
                    log_message "Warning: Command '${command[*]}' failed with '${error_output}'."
                    read -r -p "Retry with sudo for this and all future $PKG_MANAGER commands(r), continue(c), quit(q), or auto sudo when needed(a)? [r/c/q/a] " response
                else
                    log_message "Warning: Command '${command[*]}' failed with '${error_output}'."
                    read -r -p "Retry with sudo(r), continue without sudo(c), quit(q), or auto sudo when needed(a)? [r/c/q/a] " response
                fi

                case "$response" in
                    [Rr])
                        if $is_pkg_manager_command; then
                            PKG_MANAGER_PERMISSION=true
                        fi
                        log_message "Info: Retrying ${command[*]} with sudo ..."
                        log sudo "${command[@]}"
                        ;;
                    [Cc])
                        ;;
                    [aA])
                        SUDO_MODE=auto
                        setup_temporary_sudo_timeout
                        log_message "Info: Retrying ${command[*]} with sudo and setting sudo-mode=auto ..."
                        log sudo "${command[@]}"
                        ;;
                    *)
                        log_message "Info: Exiting."
                        exit 1
                        ;;
                esac
                ;;
            auto)
                setup_temporary_sudo_timeout
                if $is_pkg_manager_command; then
                    PKG_MANAGER_PERMISSION=true
                fi
                log log_message "Warning: Command '${command[*]}' failed with: '${error_output}'. Using sudo..."
                log sudo "${command[@]}"
                ;;
            continue)
                log_message "Warning: Command '${command[*]}' failed with: '${error_output}'. Continuing without sudo..."
                ;;
            error)
                log_message "Error: Command '${command[*]}' failed with '${error_output}'. Sudo is required, but mode is set to 'error'. Exiting."
                exit 1
                ;;
        esac
    }

    is_pkg_manager_command=$([ "$1" == "$PKG_MANAGER" ] && echo true || echo false)

    if [[ "$SUDO_MODE" == "force" || ( "$is_pkg_manager_command" == true && "$PKG_MANAGER_PERMISSION" == true ) ]]; then
        log sudo "${command[@]}"
        return
    fi

    error_output=$("${command[@]}" 2>&1)
    exit_code=$?

    if needs_sudo "$exit_code" "$error_output"; then
        handle_sudo_request "${command[@]}"
    fi
}

# Checks for a new version of the installer script and prompts the user to update.
check_script_update() {
    local latest_url="https://github.com/wieluk/psychopy_linux_installer/releases/latest/download/psychopy_linux_installer"
    local current_version latest_version rerun_cmd

    # Extract version information from the current and latest scripts.
    current_version=$(grep -m 1 'Version:' "$0" | sed 's/[^0-9.]//g')
    latest_version=$(curl -sL "$latest_url" | grep -m 1 'Version:' | sed 's/[^0-9.]//g')

    if is_version_greater "$latest_version" "$current_version"; then
        echo -e "\nA new version ($latest_version) of the installer script is available."
        echo "🔹 Repository: https://github.com/wieluk/psychopy_linux_installer"
        echo "🔹 Releases:   https://github.com/wieluk/psychopy_linux_installer/releases"
        echo "🔹 Issues:   https://github.com/wieluk/psychopy_linux_installer/issues"
        echo

        local script_path
        script_path=$(readlink -f "$0")

        read -r -p "Would you like to update? (y/n) " response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            log_message "Info: Updating to version $latest_version..."

            # Download and replace the current script with the latest release.
            if curl -sLo "$script_path" "$latest_url"; then
                log_message "Info: Update completed successfully."
                rerun_cmd=$(create_rerun_command)
                log_message "Note: To re-run the installer with the current settings, use:"
                log_message "Note: $rerun_cmd"
                exit 0
            else
                log_message "Warning: Failed to download the update. Continuing with the current version."
            fi
        fi
    fi
}

# Determines the operating system and its version.
detect_os_version() {
    OS_VERSION=""
    OS_VERSION_LINK=""

    local major_version version ID VERSION_ID
    if [ -f /etc/os-release ]; then
        . /etc/os-release
        if [ -n "$ID" ] && [ -n "$VERSION_ID" ]; then
            ID=$(echo "$ID" | tr '[:upper:]' '[:lower:]')
            VERSION_ID=$(echo "$VERSION_ID" | tr '[:upper:]' '[:lower:]')
            major_version=$(echo "$VERSION_ID" | cut -d. -f1)

            OS_VERSION="${ID}-${major_version}"

            if [ "$ID" = "ubuntu" ]; then
                OS_VERSION_LINK="${ID}-${VERSION_ID}"
            else
                OS_VERSION_LINK="$OS_VERSION"
            fi
            return
        fi
    fi

    if command -v lsb_release > /dev/null 2>&1; then
        ID=$(lsb_release -si | tr '[:upper:]' '[:lower:]')
        version=$(lsb_release -sr | tr '[:upper:]' '[:lower:]')
        major_version=$(echo "$version" | cut -d. -f1)

        OS_VERSION="${ID}-${major_version}"

        if [ "$ID" = "ubuntu" ]; then
            OS_VERSION_LINK="${ID}-${version}"
        else
            OS_VERSION_LINK="$OS_VERSION"
        fi
        return
    fi

    log_message "Warning: Unable to detect OS version."
    OS_VERSION="unknown"
    OS_VERSION_LINK="unknown"
    return
}

# Identifies the available package manager (apt-get, yum, etc.).
detect_package_manager() {
    if command -v apt-get > /dev/null 2>&1; then
        echo "apt-get"
    elif command -v yum > /dev/null 2>&1; then
        echo "yum"
    elif command -v dnf > /dev/null 2>&1; then
        echo "dnf"
    elif command -v pacman > /dev/null 2>&1; then
        echo "pacman"
    elif command -v zypper > /dev/null 2>&1; then
        echo "zypper"
    else
        log_message "Error: No compatible package manager found. Exiting."
        exit 1
    fi
}

# Updates the package manager's database.
update_package_manager() {
    case $PKG_MANAGER in
        apt-get) sudo_wrapper apt-get update -qq ;;
        yum) sudo_wrapper yum makecache -q ;;
        dnf) sudo_wrapper dnf makecache -q ;;
        pacman) log_message "Warning: Skipping 'pacman -Syu' to avoid unintended system upgrades. If you encounter a lot of 'package not found' errors, manually run 'sudo pacman -Syu' to update your package database, then rerun this script." ;;
        zypper) sudo_wrapper zypper refresh ;;
        *) log_message "Error: No compatible package manager found. Exiting."; exit 1 ;;
    esac
}

# Installs the provided packages via the identified package manager.
install_packages() {
    local packages=("$@")

    # Try batch install first
    local available_packages
    read -r -a available_packages <<< "$(filter_installable_packages "${packages[@]}")"

    # Using grep to compute the difference between packages and available_packages
    diff=$(printf "%s\n" "${packages[@]}" | grep -vxFf <(printf "%s\n" "${available_packages[@]}") | paste -sd, -)
    [ -n "$diff" ] && log_message "Warning: The following packages are not available and will be skipped: $diff"

    # Check if the available_packages array is empty
    if [ ${#available_packages[@]} -eq 0 ]; then
        log_message "Warning: No valid packages found for installation."
        return
    fi

    if {
        case "$PKG_MANAGER" in
            apt-get) sudo_wrapper apt-get install -y -qq "${available_packages[@]}" ;;
            yum)     sudo_wrapper yum install -y -q   "${available_packages[@]}" ;;
            dnf)     sudo_wrapper dnf install -y -q   "${available_packages[@]}" ;;
            pacman)  sudo_wrapper pacman -S --needed --noconfirm "${available_packages[@]}" ;;
            zypper)  sudo_wrapper zypper install -y   "${available_packages[@]}" ;;
            *)       log_message "Error: No compatible package manager found. Exiting." ; exit 1 ;;
        esac
    }; then
        return 0
    else
        log_message "Warning: Batch installation failed. Falling back to per-package installation. This might take sometime ..."
    fi

    # If batch install fails, fallback to installing packages one by one
    for package in "${packages[@]}"; do
        case $PKG_MANAGER in
            apt-get) sudo_wrapper apt-get install -y -qq "$package" || log_message "Warning: Package $package not found, skipping." ;;
            yum) sudo_wrapper yum install -y -q "$package" || log_message "Warning: Package $package not found, skipping." ;;
            dnf) sudo_wrapper dnf install -y -q "$package" || log_message "Warning: Package $package not found, skipping." ;;
            pacman) sudo_wrapper pacman -S --needed --noconfirm "$package" || log_message "Warning: Package $package not found, skipping." ;;
            zypper) sudo_wrapper zypper install -y "$package" || log_message "Warning: Package $package not found, skipping." ;;
            *) log_message "Error: No compatible package manager found. Exiting."; exit 1 ;;
        esac
    done
}

# Installs dependency groups (e.g. script_deps, python_build_deps, etc.).
install_dependencies() {
    local dep_type dependencies script_deps psychopy_deps fonts python_build_deps wxpython_deps python_with_venv

    dep_type="$1"
    dependencies=()

    case $PKG_MANAGER in
        apt-get)
            script_deps=(curl git jq)
            psychopy_deps=(libasound2-dev libegl1-mesa-dev libglib2.0-dev libgtk-3-dev libnotify4 libusb-1.0-0-dev libwebkit2gtk-4.0-dev libwebkit2gtk-4.1-dev libxcb-cursor0 libxcb-xinerama0 libxkbcommon-x11-0 libsdl2-dev libglu1-mesa-dev portaudio19-dev pulseaudio pulseaudio-utils)
            fonts=(fonts-dejavu fonts-liberation fontconfig)
            python_build_deps=(build-essential libbz2-dev libffi-dev libreadline-dev libsqlite3-dev libssl-dev make xz-utils zlib1g-dev)
            wxpython_deps=(freeglut3-dev g++ gstreamer1.0-plugins-base gstreamer1.0-tools gstreamer1.0-x libgtk2.0-dev libjpeg-dev libnotify-dev libpng-dev libsm-dev libtiff-dev make)
            python_with_venv=(python3 python3-dev python3-pip python3-venv)
            ;;
        yum|dnf)
            script_deps=(curl git jq)
            psychopy_deps=(alsa-lib-devel gtk3-devel libnotify mesa-libEGL-devel mesa-libGLU-devel portaudio-devel pulseaudio pulseaudio-utils SDL2-devel webkit2gtk3-devel webkit2gtk4.0-devel libusb1-devel)
            fonts=(fontconfig dejavu-sans-fonts dejavu-serif-fonts liberation-sans-fonts liberation-serif-fonts liberation-mono-fonts)
            python_build_deps=(bzip2-devel gcc libffi-devel make openssl-devel readline-devel sqlite-devel xz-devel zlib-devel)
            wxpython_deps=(freeglut-devel gcc-c++ gstreamer1-devel gtk2-devel libSM-devel libjpeg-devel libjpeg-turbo-devel libnotify-devel libpng-devel libtiff-devel make glib2-devel)
            python_with_venv=(python3 python3-devel python3-pip python3-venv)
            ;;
        pacman)
            script_deps=(curl git jq)
            psychopy_deps=(alsa-lib gtk3 libnotify libusb mesa portaudio pulseaudio pulseaudio-utils SDL2 webkit2gtk xcb-util-cursor libxcb glu)
            fonts=(ttf-dejavu ttf-liberation noto-fonts gnu-free-fonts)
            python_build_deps=(base-devel bzip2 libffi make openssl readline sqlite xz zlib)
            wxpython_deps=(freeglut gcc glib2 gstreamer gtk2 libjpeg libpng libsm libtiff make mesa)
            python_with_venv=(python python-pip python-virtualenv)
            ;;
        zypper)
            script_deps=(curl git jq)
            psychopy_deps=(alsa-devel gtk3-devel libnotify4 libusb-1_0-devel libxcb-xinerama0 portaudio-devel pulseaudio pulseaudio-utils SDL2-devel)
            fonts=(dejavu-fonts liberation-fonts fontconfig)
            python_build_deps=(gcc libffi-devel libopenssl-devel make readline-devel sqlite3-devel xz-devel zlib-devel)
            wxpython_deps=(freeglut-devel gcc-c++ glib2-devel gstreamer-plugins-base libSM-devel libjpeg-turbo libnotify-devel libpng16-devel make libtiff-devel)
            python_with_venv=(python3 python3-devel python3-pip python3-virtualenv)
            ;;
        *)
            log_message "Error: No compatible package manager found. Exiting."; exit 1
            ;;
    esac

    case $dep_type in
        script_deps) dependencies=("${script_deps[@]}") ;;
        python_build_deps) dependencies=("${python_build_deps[@]}") ;;
        psychopy_deps) dependencies=("${psychopy_deps[@]}") ;;
        fonts) dependencies=("${fonts[@]}") ;;
        wxpython_deps) dependencies=("${wxpython_deps[@]}") ;;
        python_with_venv) dependencies=("${python_with_venv[@]}") ;;
        *) log_message "Error: Invalid dependency type specified. Exiting."; exit 1 ;;
    esac

    install_packages "${dependencies[@]}"
}

# Filters and returns a list of packages available for installation.
filter_installable_packages() {
    local filtered_packages=()

    for package in "$@"; do
        # Skip conficting packages for specific OS versions
        case "$OS_VERSION" in
            ubuntu-24) [[ "$package" == "libwebkit2gtk-4.0-dev" ]] && continue ;;
            ubuntu-20) [[ "$package" == "libwebkit2gtk-4.1-dev" ]] && continue ;;
            debian-11) [[ "$package" == "libwebkit2gtk-4.1-dev" ]] && continue ;;
            pop-22) [[ "$package" == "pulseaudio" ]] && continue ;;
            fedora-39|fedora-40|fedora-41) [[ "$package" == "pulseaudio" ]] && continue ;;
            rocky-9|centos-9) [[ "$package" == "pulseaudio" || "$package" == "portaudio-devel" ]] && continue ;;
            linuxmint-22) [[ "$package" == "libwebkit2gtk-4.0-dev" ]] && continue ;;
            manjarolinux-25) [[ "$package" == "pulseaudio-utils" || "$package" == "pulseaudio" ]] && continue ;;
        esac

        case "$PKG_MANAGER" in
            apt-get)
                if apt-cache show "$package" &>/dev/null; then
                    filtered_packages+=("$package")
                fi
                ;;
            yum|dnf)
                if $PKG_MANAGER info "$package" &>/dev/null; then
                    filtered_packages+=("$package")
                fi
                ;;
            pacman)
                if pacman -Si "$package" &>/dev/null; then
                    filtered_packages+=("$package")
                fi
                ;;
            zypper)
                if zypper search --match-exact "$package" &>/dev/null; then
                    filtered_packages+=("$package")
                fi
                ;;
        esac
    done
    echo "${filtered_packages[@]}"
}

# Verifies if the specific Python version is available through the package manager.
check_python_in_package_manager() {
    local available_version

    case $PKG_MANAGER in
        apt-get)
            available_version=$(apt-cache policy python3 | grep -m 1 "Candidate:" | awk '{print $2}' | cut -d'.' -f1,2)
            ;;
        yum)
            available_version=$(yum info python3 2> /dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
            ;;
        dnf)
            available_version=$(dnf info python3 2> /dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
            ;;
        pacman)
            available_version=$(pacman -Si python 2> /dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
            ;;
        zypper)
            available_version=$(zypper info python3 2> /dev/null | grep -m 1 Version | awk '{print $3}' | cut -d'.' -f1,2)
            ;;
        *)
            log_message "Error: No compatible package manager found. Exiting."; exit 1
            ;;
    esac

    if [ "$available_version" == "$PYTHON_VERSION" ]; then
        return 0
    else
        log_message "Warning: Python $PYTHON_VERSION not available in $PKG_MANAGER."
        return 1
    fi
}

# Compares two version strings and returns true if the first is greater.
is_version_greater() {
    if [[ "$1" =~ ^[0-9]+(\.[0-9]+)*$ ]] && [[ "$2" =~ ^[0-9]+(\.[0-9]+)*$ ]]; then
        [ "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1" ]
    else
        return 1
    fi
}

# Retrieves and sorts available versions for a package from PyPI.
fetch_versions_from_pypi() {
    local package="$1"
    curl -s "https://pypi.org/pypi/$package/json" | jq -r '.releases // {} | keys[]' | sort -Vr
}

# Retrieves the latest version for a package from PyPI.
get_latest_pypi_version() {
    local pkg="$1"
    local var_name="$2"

    local version
    version=$(curl -s "https://pypi.org/pypi/$pkg/json" | jq -r '.info.version')
    if [ -z "$version" ] || [ "$version" = "null" ]; then
        log_message "Error: Unable to fetch the latest version for package ${package_name}. Exiting."
        exit 1
    fi
    declare -n result=$var_name
    # shellcheck disable=SC2034
    result="$version"
}

# Converts a PsychoPy package spec to the appropriate Git URL if needed.
convert_psychopy_req_to_git_url() {
    local package_spec="$1"

    if [[ ! $package_spec =~ ^psychopy== ]] || [ "$PSYCHOPY_GIT_TAG" != "true" ]; then
        echo "$package_spec"
        return 0
    fi

    local version=${package_spec#psychopy==}
    echo "git+https://github.com/psychopy/psychopy.git@${version}"
}

# Verifies that the requested package version exists on PyPI (or Git).
check_pypi_for_version() {
    local package="$1"
    local version="$2"
    local github_api="https://api.github.com/repos/psychopy/psychopy/git/refs/tags"
    local pypi_api="https://pypi.org/pypi"

    if curl -s "${pypi_api}/${package}/${version}/json" | jq -e .info.version > /dev/null; then
        return 0
    fi

    if [ "${package}" = "psychopy" ]; then
        if curl -s -H "Accept: application/vnd.github.v3+json" \
            "${github_api}/${version}" | jq -e .ref > /dev/null; then
            log_message "Warning: ${package} version ${version} not found on PyPi but as git tag"
            PSYCHOPY_GIT_TAG=true
            return 0
        fi
    fi

    log_message "Error: ${package} version ${version} not found on PyPI. Exiting."
    exit 1
}

# Confirms that Python, pip, and venv are available.
check_python_env() {
    local python_cmd="$1"
    if ! command -v "$python_cmd" > /dev/null 2>&1; then
        log_message "Error: $python_cmd not found. Exiting."
        exit 1
    fi

    if ! "$python_cmd" -m venv --help > /dev/null 2>&1; then
        log_message "Error: $python_cmd found, but venv module is not available. Exiting."
        exit 1
    fi

    if ! "$python_cmd" -m pip --version > /dev/null 2>&1; then
        log_message "Error: $python_cmd found, but pip is not installed. Exiting."
        exit 1
    fi
}

# Builds Python from source, using the specified version.
build_python() {
    local official_base_url latest_patch_version official_url temp_file temp_dir
    log_message "Info: Building Python ${PYTHON_VERSION} from source. This may take some time..."
    official_base_url="https://www.python.org/ftp/python/"

    latest_patch_version=$(curl -s "${official_base_url}" | grep -oP "${PYTHON_VERSION}\.[0-9]+/" | sort -V | tail -n 1 | sed 's:/$::')

    official_url="${official_base_url}${latest_patch_version}/Python-${latest_patch_version}.tgz"
    temp_file="Python-${latest_patch_version}.tgz"
    temp_dir="Python-${latest_patch_version}_temp"

    if ! log curl -L -o "${temp_file}" "${official_url}"; then
        log_message "Error: Failed to download Python source from ${official_url}. Exiting."
        exit 1
    fi

    mkdir -p "${temp_dir}" || { log_message "Error: Failed to create temp directory. Exiting."; exit 1; }

    if ! tar -xf "${temp_file}" -C "${temp_dir}"; then
        log_message "Error: Failed to extract ${temp_file}.  Exiting."
        exit 1
    fi

    cd "${temp_dir}/Python-${latest_patch_version}" || { log_message "Error: Failed to change directory.  Exiting."; exit 1; }
    log ./configure --enable-optimizations --with-ensurepip=install --prefix=/usr/local/psychopy_python
    log make -j "$(nproc)"
    sudo_wrapper make altinstall
    cd "${PSYCHOPY_DIR}" || { log_message "Error: Failed to return to psychopy directory. Exiting."; exit 1; }

    sudo_wrapper rm -rf "${temp_dir}" "${temp_file}"
    return 0
}

# Attempts to install Python from a GitHub release asset.
install_python_from_github() {
    local asset_name api_url github_api_header assets_json temp_file temp_dir github_download_url python_version_pattern latest_release_tag

    github_api_header="Accept: application/vnd.github.v3+json"
    latest_release_tag=$(curl -s -H "$github_api_header" "https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest" | jq -r .tag_name)
    api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/tags/v${SCRIPT_VERSION}"
    assets_json=$(curl -s -H "$github_api_header" "$api_url")

    python_version_pattern="python-${PYTHON_VERSION}\.[0-9]+-${PROCESSOR_STRUCTURE}-${OS_VERSION}\.tar\.gz"
    asset_name=$(echo "$assets_json" | jq -r '.assets // [] | .[].name' | grep -E "$python_version_pattern" | sort -V | tail -n 1)

    # If no matching asset is found AND the script version is NOT the latest, check the latest release
    if [[ -z "$asset_name" && "v${SCRIPT_VERSION}" != "$latest_release_tag" ]]; then
        log_message "Warning: No matching Python version found in v${SCRIPT_VERSION}. Checking the latest release ($latest_release_tag)..."
        api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest"
        assets_json=$(curl -s -H "$github_api_header" "$api_url")
        asset_name=$(echo "$assets_json" | jq -r '.assets // [] | .[].name' | grep -E "$python_version_pattern" | sort -V | tail -n 1)
    fi

    if [ -z "$asset_name" ]; then
        log_message "Warning: No matching Python version found in v${SCRIPT_VERSION} or latest release ($latest_release_tag) for Python ${PYTHON_VERSION}."
        return 1
    fi

    github_download_url=$(echo "$assets_json" | jq -r --arg name "$asset_name" '.assets // [] | .[] | select(.name == $name) | .browser_download_url')

    if [ -z "$github_download_url" ]; then
        log_message "Warning: Could not find a download URL for asset $asset_name."
        return 1
    fi

    log_message "Info: Downloading $asset_name from GitHub ..."
    if log curl -L -o "$asset_name" "$github_download_url"; then
        log_message "Info: Successfully downloaded ${asset_name} from GitHub release v${SCRIPT_VERSION}. Making an altinstall ..."
        temp_dir="${asset_name%.tar.gz}_temp"
        mkdir -p "$temp_dir" || { log_message "Warning: Failed to create temp directory."; return 1; }

        if tar -xf "$asset_name" -C "$temp_dir"; then
            cd "$temp_dir" || { log_message "Warning: Failed to change directory."; return 1; }
            sudo_wrapper make altinstall
            cd "${PSYCHOPY_DIR}" || { log_message "Warning: Failed to return to psychopy directory."; return 1; }
            sudo_wrapper rm -rf "$temp_dir" "$asset_name"
            return 0
        else
            log_message "Warning: Failed to extract $asset_name."
            sudo_wrapper rm -rf "$temp_dir"
            return 1
        fi
    else
        log_message "Warning: Failed to download from GitHub release."
        return 1
    fi
}

# Builds wxPython from source with the necessary build dependencies.
build_wxpython() {
    local tmp_size_gb

    log_message "Info: Installing wxPython build dependencies. This might take a while ..."
    install_dependencies wxpython_deps

    # Check /tmp size and warn if ≤2GB (non-blocking)
    tmp_size_gb=$(df -B1G --output=size /tmp 2>/dev/null | tail -n1 | tr -d ' ' || echo 0)
    [ "$tmp_size_gb" -le 2 ] && log_message "Warning: /tmp is only ${tmp_size_gb}GB. wxPython build may fail. Please increase your /tmp size."

    log_message "Info: Building wxPython $WXPYTHON_VERSION from source. This might take a while ..."
    if "$PYTHON_VENV_COMMAND" -m pip install --no-binary=wxpython --no-cache-dir --force-reinstall "wxpython==$WXPYTHON_VERSION"; then
        log_message "Info: Successfully built wxPython from source."
    else
        log_message "Error: Building wxPython from source failed. Exiting."
        exit 1
    fi
}

# Attempts to install wxPython from a GitHub released wheel.
install_wxpython_from_github() {
    local api_url assets_json latest_release_tag github_api_header wheel_name renamed_wheel download_url python_version_major_minor

    github_api_header="Accept: application/vnd.github.v3+json"
    latest_release_tag=$(curl -s -H "$github_api_header" "https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest" | jq -r .tag_name)
    api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/tags/v${SCRIPT_VERSION}"
    assets_json=$(curl -s -H "$github_api_header" "$api_url")

    python_version_major_minor=$(echo "${PYTHON_VERSION}" | awk -F. '{printf "%s%s", $1, $2}')
    wheel_name="wxPython-${WXPYTHON_VERSION}-cp${python_version_major_minor}-cp${python_version_major_minor}-${PROCESSOR_STRUCTURE}-${OS_VERSION}.whl"
    download_url=$(echo "$assets_json" | jq -r --arg name "$wheel_name" '.assets // [] | .[] | select(.name == $name) | .browser_download_url')

    # If no matching wheel is found AND the script version is NOT the latest, check the latest release
    if [[ -z "$download_url" && "v${SCRIPT_VERSION}" != "$latest_release_tag" ]]; then
        log_message "Info: No matching wxPython wheel found in v${SCRIPT_VERSION}. Checking the latest release ($latest_release_tag)..."
        api_url="https://api.github.com/repos/wieluk/psychopy_linux_installer/releases/latest"
        assets_json=$(curl -s -H "$github_api_header" "$api_url")
        download_url=$(echo "$assets_json" | jq -r --arg name "$wheel_name" '.assets // [] | .[] | select(.name == $name) | .browser_download_url')
    fi

    # If still not found, exit with an error
    if [ -z "$download_url" ]; then
        log_message "Warning: No matching wxPython wheel found in v${SCRIPT_VERSION} or latest release ($latest_release_tag) for wxPython ${WXPYTHON_VERSION}."
        return 1
    fi

    log_message "Info: Downloading $wheel_name from GitHub ..."
    if log curl -L -o "$wheel_name" "$download_url"; then
        log_message "Info: Successfully downloaded wxPython wheel from GitHub release. Installing wxPython from $wheel_name..."
        renamed_wheel="${wheel_name%-"${OS_VERSION}".whl}.whl"
        mv "$wheel_name" "$renamed_wheel"
        if log "$PYTHON_VENV_COMMAND" -m pip install "$renamed_wheel"; then
            log_message "Info: Installed wxPython from $renamed_wheel"
            sudo_wrapper mkdir -p /usr/local/psychopy_python/wx_wheels
            sudo_wrapper mv "$renamed_wheel" /usr/local/psychopy_python/wx_wheels/
            return 0
        else
            log_message "Warning: Installing wxPython from $renamed_wheel failed."
            rm "$renamed_wheel"
            return 1
        fi
    else
        log_message "Warning: Downloading $wheel_name failed."
        return 1
    fi
}

# Creates desktop shortcuts for PsychoPy applications.
create_desktop_shortcut() {
    local desktop_shortcut
    local desktop_dir="${HOME}/.local/share/applications/"
    local psychopy_exec="${PSYCHOPY_DIR}/bin/psychopy"
    local resources_dir="${PSYCHOPY_DIR}/Resources"
    local shortcuts=()

    desktop_shortcut="$(xdg-user-dir DESKTOP)"

    if [ -n "$VENV_NAME" ]; then
        shortcuts+=(
            "--no-splash" "$VENV_NAME" "psychopy.png"
            "--builder --no-splash" "Builder $VENV_NAME" "builder.png"
            "--coder --no-splash" "Coder $VENV_NAME" "coder.png"
        )
    else
        shortcuts+=(
            "--no-splash" "PsychoPy (v${PSYCHOPY_VERSION}) Python(v${PYTHON_VERSION})" "psychopy.png"
            "--builder --no-splash" "PsychoPy Builder (v${PSYCHOPY_VERSION}) Python(v${PYTHON_VERSION})" "builder.png"
            "--coder --no-splash" "PsychoPy Coder (v${PSYCHOPY_VERSION}) Python(v${PYTHON_VERSION})" "coder.png"
        )
    fi

    if [ ! -d "$desktop_shortcut" ]; then
        log_message "Warning: Desktop directory '$desktop_shortcut' does not exist. Skipping shortcut creation."
        return
    fi

    mkdir -p "${resources_dir}"

    for ((i=0; i<${#shortcuts[@]}; i+=3)); do
        local exec_args="${shortcuts[i]}"
        local pretty_name="${shortcuts[i+1]}"
        local icon_file="${shortcuts[i+2]}"
        local icon_url="https://raw.githubusercontent.com/wieluk/psychopy_linux_installer/main/Resources/${icon_file}"
        local desktop_file="${desktop_shortcut}/${pretty_name}.desktop"
        local icon_path="${resources_dir}/${icon_file}"

        if curl --output /dev/null --silent --head --fail "${icon_url}"; then
            log curl -s -o "${icon_path}" "${icon_url}"
        else
            log_message "Warning: Icon file ${icon_url} not found, skipping..."
        fi

        local icon_line=""
        if [ -f "$icon_path" ]; then
            icon_line="Icon=${icon_path}"
        fi

        local desktop_content="[Desktop Entry]
Version=1.0
Name=${pretty_name}
Comment=Run PsychoPy version ${PSYCHOPY_VERSION} with ${exec_args}
Exec=${psychopy_exec} ${exec_args}
${icon_line}
Terminal=false
Type=Application
Categories=Education;Science;"

        sh -c "echo '$desktop_content' > '$desktop_file'"
        sudo_wrapper chmod +x "$desktop_file"
        sudo_wrapper chown "$USER" "$desktop_file"
        gio set "$desktop_file" metadata::trusted true
        sudo_wrapper ln -sf "$desktop_file" "${desktop_dir}${pretty_name}.desktop"
    done
    log_message "Info: Desktop shortcuts created successfully."
}

# Adds the PsychoPy installation's bin directory to the user's PATH.
add_psychopy_to_path() {
    local shell_name
    local bin_dir="${PSYCHOPY_DIR}/.bin"

    if [ -n "$VENV_NAME" ]; then
        local target_bin="${bin_dir}/${VENV_NAME}"
    else
        local target_bin="${bin_dir}/psychopy_${PSYCHOPY_VERSION}_py${PYTHON_VERSION}"
    fi

    shell_name=$(basename "$SHELL")
    mkdir -p "$bin_dir"
    ln -sf "${PSYCHOPY_DIR}/bin/psychopy" "$target_bin"

    local config_file=""
    local path_line=""

    case $shell_name in
        bash)
            config_file="$HOME/.bashrc"
            path_line="export PATH=\"${bin_dir}:\$PATH\""
            ;;
        zsh)
            config_file="$HOME/.zshrc"
            path_line="export PATH=\"${bin_dir}:\$PATH\""
            ;;
        fish)
            config_file="$HOME/.config/fish/config.fish"
            path_line="set -gx PATH \"${bin_dir}\" \$PATH"
            ;;
        csh|tcsh)
            config_file="$HOME/.${shell_name}rc"
            path_line="setenv PATH ${bin_dir}:\$PATH"
            ;;
        *)
            log_message "Warning: Unsupported shell: $shell_name; PsychoPy not added to path"
            ;;
    esac

    if ! grep -Fxq "$path_line" "$config_file"; then
        sh -c "echo '$path_line' >> \"$config_file\""
        log_message "Info: Added PsychoPy to the PATH in $config_file."
    else
        log_message "Info: PsychoPy is already in the PATH in $config_file."
    fi
}


main() {
    PKG_MANAGER_PERMISSION=false
    PSYCHOPY_GIT_TAG=false
    TEMPORARY_SUDO_SETUP_DONE=false
    use_gui=false

    tmp_log_file="/tmp/psychopy_linux_installer_$(date +%Y%m%d_%H%M%S).log"
    LOG_FILE="$tmp_log_file"
    log_message "Note: Logging to temporary file: ${LOG_FILE}"

    for arg in "$@"; do
        if [[ "$arg" == "--gui" ]]; then
            use_gui=true
            break
        fi
    done

    if $use_gui; then
        if ! command -v zenity &> /dev/null; then
            log_message "Error: zenity is not installed or not available in PATH. Cannot use GUI mode. Exiting."
            exit 1
        else
            show_gui
        fi
    else
        process_arguments "$@"
    fi

    if [ -n "$REQUIREMENTS_FILE" ]; then
        log_message "Info: Parsing requirements file: $REQUIREMENTS_FILE..."
        parse_requirements_file "$REQUIREMENTS_FILE"
    fi

    # Ensure defaults for unset variables
    for key in "${!DEFAULT_OPTS[@]}"; do
        if [ -z "${!key+x}" ]; then
            eval "$key='${DEFAULT_OPTS[$key]}'"
        fi
    done

    VENV_NAME=${VENV_NAME//[[:space:]]/_}

    if $use_gui; then
        rerun_cmd=$(create_rerun_command)
        log_message "Note: To re-run the installer with the current --gui settings, use:"
        log_message "Note: $rerun_cmd"
        echo
    fi

    # Detect OS version, architecture and script version
    detect_os_version
    PROCESSOR_STRUCTURE=$(uname -s | tr '[:upper:]' '[:lower:]')_$(uname -m)
    SCRIPT_VERSION=$(grep -m 1 'Version:' "$0" | sed 's/[^0-9.]//g')
    log_message "Info: Initiating PsychoPy(${PSYCHOPY_VERSION}) installation using psychopy_linux_installer v${SCRIPT_VERSION} on ${OS_VERSION} (${PROCESSOR_STRUCTURE})."

    # Detect package manager
    PKG_MANAGER=$(detect_package_manager)

    # Update package manager
    log_message "Info: Updating ${PKG_MANAGER} package manager."
    update_package_manager "$PKG_MANAGER"

    # Install basic dependencies
    log_message "Info: Installing git, curl, and jq."
    install_dependencies script_deps

    # Check for script update
    if [ "$NON_INTERACTIVE" = false ]; then
        check_script_update
    fi

    # Determine PsychoPy version to install
    if [ "$PSYCHOPY_VERSION" == "latest" ]; then
        get_latest_pypi_version "psychopy" PSYCHOPY_VERSION
    elif [ "$PSYCHOPY_VERSION" != "git" ]; then
        check_pypi_for_version psychopy "${PSYCHOPY_VERSION}"
    fi

    # Install PsychoPy dependencies
    log_message "Info: Installing PsychoPy dependencies. This might take a while ..."
    install_dependencies psychopy_deps

    # Set up PsychoPy installation directory
    if [ -n "$VENV_NAME" ]; then
        PSYCHOPY_DIR="${INSTALL_DIR}/${VENV_NAME}"
    else
        PSYCHOPY_DIR="${INSTALL_DIR}/psychopy_${PSYCHOPY_VERSION}_py${PYTHON_VERSION}"
    fi

    if [ -d "${PSYCHOPY_DIR}" ]; then
        if [ "$FORCE_OVERWRITE" = true ]; then
            log_message "Warning: Directory ${PSYCHOPY_DIR} already exists. Overwriting ..."
            sudo_wrapper rm -rf "${PSYCHOPY_DIR}"
            sudo_wrapper mkdir -p "${PSYCHOPY_DIR}"
        else
            log_message "Error: Directory ${PSYCHOPY_DIR} already exists. Use the --force-overwrite flag to overwrite. Exiting."
            exit 1
        fi
    else
        log_message "Info: Creating PsychoPy directory at ${PSYCHOPY_DIR} ..."
        sudo_wrapper mkdir -p "${PSYCHOPY_DIR}"
    fi

    [ -w "${PSYCHOPY_DIR}" ] || sudo_wrapper chown "$USER" "${PSYCHOPY_DIR}"

    if ! [ -w "${PSYCHOPY_DIR}" ] || ! cd "${PSYCHOPY_DIR}"; then
        log_message "Error: Failed to access or change directory to ${PSYCHOPY_DIR}. Exiting."
        exit 1
    fi

    # Transition logs into psychopy_dir while keeping the same filename
    FINAL_LOG_FILE="${PSYCHOPY_DIR}/$(basename "$tmp_log_file")"

    if [ -f "$tmp_log_file" ]; then
        mv "$tmp_log_file" "$FINAL_LOG_FILE"
    fi
    LOG_FILE="$FINAL_LOG_FILE"
    log_message "Note: Installation directory is set. Log has been moved to: ${LOG_FILE}"

    # Install python and create venv
    if [ "$BUILD_PYTHON" = true ] || ! check_python_in_package_manager; then
        if [ "$BUILD_PYTHON" = true ]; then
            log_message "Info: Installing python build dependencies ..."
            install_dependencies python_build_deps
            build_python
        else
            if [ -x "/usr/local/psychopy_python/bin/python${PYTHON_VERSION}" ]; then
                log_message "Info: Python version ${PYTHON_VERSION} is already installed in /usr/local/psychopy_python. Skipping installation."
            else
                log_message "Info: Installing python build dependencies ..."
                install_dependencies python_build_deps
                if install_python_from_github; then
                    :
                else
                    build_python
                fi
            fi
        fi

        if [ ! -x "/usr/local/psychopy_python/bin/python${PYTHON_VERSION}" ]; then
            log_message "Error: python${PYTHON_VERSION} not found in /usr/local/psychopy_python. Something went wrong while installing/building. Try --build=python and --verbose as arguments. Exiting."
            exit 1
        fi
        export PATH=/usr/local/psychopy_python/bin:$PATH
        /usr/local/psychopy_python/bin/python"${PYTHON_VERSION}" -m venv "${PSYCHOPY_DIR}"
    else
        log_message "Info: Python${PYTHON_VERSION} can be installed via package manager. Installing ..."
        install_dependencies python_with_venv
        check_python_env "python${PYTHON_VERSION}"
        python"${PYTHON_VERSION}" -m venv "${PSYCHOPY_DIR}"
    fi

    # Activate venv
    log_message "Info: Succesfully created Python${PYTHON_VERSION} venv in ${PSYCHOPY_DIR}."
    PYTHON_VENV_COMMAND="${PSYCHOPY_DIR}/bin/python"
    check_python_env "$PYTHON_VENV_COMMAND"

    # Upgrade pip and install required Python packages
    log_message "Info: Upgrading pip, distro, sip, six, psychtoolbox, attrdict, setuptools, wheel ..."
    log "$PYTHON_VENV_COMMAND" -m pip install -U pip distro sip six psychtoolbox setuptools wheel
    if [[ "${PYTHON_VERSION}" == "3.8" || "${PYTHON_VERSION}" == "3.9" ]]; then
        log "$PYTHON_VENV_COMMAND" -m pip install -U attrdict
    elif [[ "${PYTHON_VERSION}" == "3.10" ]]; then
        log "$PYTHON_VENV_COMMAND" -m pip install -U attrdict3
    fi

    # Determine wxPython version and install it
    log_message "Info: Installing wxpython ..."
    if [ "$WXPYTHON_VERSION" = "latest" ]; then
        get_latest_pypi_version "wxPython" WXPYTHON_VERSION
    elif [ "$WXPYTHON_VERSION" != "git" ]; then
        check_pypi_for_version wxpython "${WXPYTHON_VERSION}"
    fi

    if [ "$WXPYTHON_VERSION" = "git" ]; then
        log_message "Info: Installing wxPython build dependencies. This might take a while ..."
        install_dependencies wxpython_deps
        log_message "Info: Building wxPython from git. This might take a while ..."
        log "$PYTHON_VENV_COMMAND" -m pip install git+https://github.com/wxWidgets/Phoenix
    elif [ "$BUILD_WX" = true ]; then
        build_wxpython
    else
        if log "$PYTHON_VENV_COMMAND" -m pip install --only-binary=:all: --find-links /usr/local/psychopy_python/wx_wheels/ "wxpython==$WXPYTHON_VERSION"; then
            log_message "Info: Successfully installed wxPython $WXPYTHON_VERSION from local wheel."
        elif log "$PYTHON_VENV_COMMAND" -m pip install --only-binary=:all: --find-links "https://extras.wxpython.org/wxPython4/extras/linux/gtk3/$OS_VERSION_LINK/" "wxPython==$WXPYTHON_VERSION"; then
            log_message "Info: Successfully installed wxPython $WXPYTHON_VERSION from extras.wxpython.org."
        elif install_wxpython_from_github; then
            :
        else
            build_wxpython
        fi
    fi

    if ! "$PYTHON_VENV_COMMAND" -m pip show wxPython &> /dev/null; then
        log_message "Error: wxPython is not installed. Something went wrong during the installation. Try --build=wxpython and --verbose as arguments. Exiting."
        exit 1
    fi

    if [ -n "$REQUIREMENTS_FILE" ]; then
        log_message "Info: Installing packages from requirements file..."
        transformed_packages=$(echo "$BACKUP_ADDITIONAL_PACKAGES" | tr ',' '\n' | while read -r pkg; do
            convert_psychopy_req_to_git_url "$pkg"
        done)

        if log "$PYTHON_VENV_COMMAND" -m pip install -r <(echo "$transformed_packages"); then
            log_message "Info: Packages from $REQUIREMENTS_FILE installed successfully."
        else
            log_message "Warning: Failed to install packages from $REQUIREMENTS_FILE. Installing packages one by one ..."
            IFS=',' read -ra PACKAGES <<< "$BACKUP_ADDITIONAL_PACKAGES"
            for package in "${PACKAGES[@]}"; do
                log_message "Info: Installing $package..."
                transformed_pkg=$(convert_psychopy_req_to_git_url "$package")
                if log "$PYTHON_VENV_COMMAND" -m pip install "$transformed_pkg"; then
                    pkg_name="${package%%=*}"
                    installed_version=$("$PYTHON_VENV_COMMAND" -m pip show "$pkg_name" | grep Version | cut -d' ' -f2)
                    log_message "Info: $pkg_name version $installed_version installed successfully."
                else
                    log_message "Warning: Failed to install $package. Skipping."
                fi
            done
        fi
    else
        # Install PsychoPy
        log_message "Info: Installing PsychoPy version ${PSYCHOPY_VERSION}"
        if [ "$PSYCHOPY_VERSION" == "git" ]; then
            log "$PYTHON_VENV_COMMAND" -m pip install git+https://github.com/psychopy/psychopy.git@dev
        elif [ "$PSYCHOPY_GIT_TAG" = "true" ]; then
            log "$PYTHON_VENV_COMMAND" -m pip install "git+https://github.com/psychopy/psychopy.git@${PSYCHOPY_VERSION}"
        else
            log "$PYTHON_VENV_COMMAND" -m pip install psychopy=="${PSYCHOPY_VERSION}"
        fi

        if ! "$PYTHON_VENV_COMMAND" -m pip show psychopy &> /dev/null; then
            log_message "Error: PsychoPy is not installed successfully. Something went wrong during the installation. Use the --verbose flag. Exiting."
            exit 1
        fi

        # Install additional packages if specified
        if [ -n "$ADDITIONAL_PACKAGES" ]; then
            log_message "Info: Installing additional packages..."
            IFS=',' read -ra PACKAGES <<< "$ADDITIONAL_PACKAGES"
            for package in "${PACKAGES[@]}"; do
                log_message "Info: Installing $package..."
                if log "$PYTHON_VENV_COMMAND" -m pip install "$package"; then
                    installed_version=$("$PYTHON_VENV_COMMAND" -m pip show "${package%%=*}" | grep Version | cut -d' ' -f2)
                    log_message "Info: ${package%%=*} version $installed_version installed successfully."
                else
                    log_message "Warning: Failed to install $package. Skipping."
                fi
            done
        fi
    fi

    # Install numpy<2 if PsychoPy version is less than 2024.2.0
    if is_version_greater "2024.2.0" "$PSYCHOPY_VERSION"; then
        log_message "Warning: PsychoPy version < 2024.2.0, installing numpy<2"
        log "$PYTHON_VENV_COMMAND" -m pip install "numpy<2"
    fi

    # Install some basic fonts for PsychoPy
    log_message "Info: Installing some basic fonts for PsychoPy."
    install_dependencies fonts

    # Add user to the 'psychopy' group and set security limits
    log_message "Info: Adding ${USER} to psychopy group and setting security limits in /etc/security/limits.d/99-psychopylimits.conf."
    sudo_wrapper groupadd --force psychopy
    sudo_wrapper usermod -a -G psychopy "$USER"
    sudo_wrapper sh -c 'echo "@psychopy - nice -20\n@psychopy - rtprio 50\n@psychopy - memlock unlimited" > /etc/security/limits.d/99-psychopylimits.conf'

    # Create desktop shortcut
    if [ "$DISABLE_SHORTCUT" = false ]; then
        create_desktop_shortcut
    fi

    # Add PsychoPy to PATH
    if [ "$DISABLE_PATH" = false ]; then
        add_psychopy_to_path
        log_message "Note: To start PsychoPy from the system path, use:"
        if [ -n "$VENV_NAME" ]; then
            log_message "Note: ${VENV_NAME}"
        else
            log_message "Note: psychopy_${PSYCHOPY_VERSION}_py${PYTHON_VERSION}"
        fi
    fi
    log_message "Note: To start PsychoPy using the absolute path, use:"
    log_message "Note: ${PSYCHOPY_DIR}/bin/psychopy"
    log_message "Note: Please reboot to apply security limits and to refresh the system path."

    if "${PSYCHOPY_DIR}/bin/psychopy" -v &>/dev/null; then
        log_message "Info: PsychoPy installation completed successfully!"
    else
        log_message "Error: PsychoPy installation verification failed!"
    fi
}

main "$@"
